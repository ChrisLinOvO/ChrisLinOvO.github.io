[{"categories":["Notes"],"contents":"前言 紀錄一些重點\n使用 Jest 進行快照測試 每當您想要確保 UI 不會意外更改時，快照測試都是一個非常有用的工具。\n第一次執行此測試時，Jest 會在__tests__目錄內建立__snapshots__目錄，裡面建立一個 snapshot 檔案，檔名會是測試檔的名稱再加上.snap，當 UI 有變更的時候，Snapshot 就會顯示異動的部分。\n執行指令npm run test -- -u，覆蓋原本就的，產生新的 Snapshot。\n範例 // Button.js import React from \u0026#39;react\u0026#39;; const Button = ({ label }) =\u0026gt; ( \u0026lt;button\u0026gt;{label}\u0026lt;/button\u0026gt; ); export default Button; // __tests__/Button.test.js import React from \u0026#39;react\u0026#39;; import renderer from \u0026#39;react-test-renderer\u0026#39;; import Button from \u0026#39;./Button\u0026#39;; test(\u0026#39;Button component snapshot\u0026#39;, () =\u0026gt; { const component = renderer.create(\u0026lt;Button label=\u0026#34;Click Me\u0026#34; /\u0026gt;); const tree = component.toJSON(); expect(tree).toMatchSnapshot(); }); 示意快照內容如下\n// 例如：Button.test.js.snap exports[`Button component snapshot 1`] = ` \u0026lt;button\u0026gt; Click Me \u0026lt;/button\u0026gt; ` 測試覆蓋率報告（Coverage Reporting） 執行npm run test -- --coverage就可以取得測試覆蓋率的報告。如要修改配置可以參考 configuration 的部分。\njest.config.js 常用配置 testRegex 用來匹配測試文件的路徑和文件名\n範例：\ntestRegex: \u0026#39;__tests__/.*\\\\.?(spec|test)\\\\.js?$\u0026#39; testRegex 可以指定處理格式黨\n範例：\nmoduleFileExtensions: [\u0026#39;js\u0026#39;, \u0026#39;jsx\u0026#39;, \u0026#39;json\u0026#39;] transform 可指定哪些文件該如何轉換\n範例：\ntransform: { \u0026#39;\\\\.js$\u0026#39;: [ \u0026#39;es-jest\u0026#39;, { jsxDev: true, jsx: \u0026#39;automatic\u0026#39;, loader: \u0026#39;jsx\u0026#39; } ] } setupFiles 運行測試初始化配置\n範例：\nsetupFiles: [\u0026#39;\u0026lt;rootDir\u0026gt;/__tests__/setup/init.js\u0026#39;] testEnvironment 指定測試運行環境，預設默認jsdom\n範例：\ntestEnvironment: \u0026#39;jsdom\u0026#39; coverageThreshold 用於設定測試覆蓋率值\n範例：\ncoverageThreshold: { global: { statements: 80, branches: 80, functions: 80, lines: 80, }, } moduleNameMapper 可指定模塊路徑該到哪裡\n範例：\n\u0026#39;@storybook/addon-docs/(.*)\u0026#39;: \u0026#39;@storybook/addon-docs/dist/cjs/$1\u0026#39;, \u0026#39;@vzmi/ec_file_uploader_sdk\u0026#39;: \u0026#39;\u0026lt;rootDir\u0026gt;/__mocks__/file-uploader-sdk.js\u0026#39;, \u0026#39;uuid/v1\u0026#39;: \u0026#39;\u0026lt;rootDir\u0026gt;/__mocks__/uuidv1.js\u0026#39; collectCoverage 啟用覆蓋率報告\n範例：\ncollectCoverage: true collectCoverageFrom 指定哪些文件應包括在測試覆蓋率報告中\n範例：\ncollectCoverageFrom: [\u0026#39;src/**/*.{js,jsx}\u0026#39;] reporters 生成測試報告生成測試報告的方式和格式\n範例：\nreporters: [\u0026#39;default\u0026#39;, \u0026#39;jest-junit\u0026#39;] coveragePathIgnorePatterns 配置覆蓋率報告需要忽略的路徑\n範例：\ncoveragePathIgnorePatterns: [ \u0026#39;\u0026lt;rootDir\u0026gt;/conf/\u0026#39;, \u0026#39;\u0026lt;rootDir\u0026gt;/__tests__/config/\u0026#39;, \u0026#39;\u0026lt;rootDir\u0026gt;/__tests__/support/\u0026#39; ] testPathIgnorePatterns 測試需要忽略的路徑\n範例：\ntestPathIgnorePatterns: [ \u0026#39;\u0026lt;rootDir\u0026gt;/node_modules/\u0026#39;, \u0026#39;\u0026lt;rootDir\u0026gt;/__tests__/config/\u0026#39; ] globals 全局變量\n範例：\nglobals: { __DEV__: true } setupFilesAfterEnv 測試環境初始化後執行\n範例：\nsetupFilesAfterEnv: [ \u0026#39;\u0026lt;rootDir\u0026gt;/node_modules/raf/polyfill\u0026#39;, \u0026#39;\u0026lt;rootDir\u0026gt;/node_modules/regenerator-runtime/runtime\u0026#39;, \u0026#39;\u0026lt;rootDir\u0026gt;/__tests__/config/setup.js\u0026#39;, ] testRunner 指定 Jest 使用的運行器\n範例：\ntestRunner: \u0026#39;jest-jasmine2\u0026#39; maxWorkers 配置 Jest 啟動後最大工作進程數，提高測試速度\n範例：\nmaxWorkers: \u0026#39;50%\u0026#39; jest.fn() 創建一個 mock function，可模擬函數被調用，也可設置返回值\n// 創建一個模擬函數 const mockFunction = jest.fn(); // 設定模擬函數返回值 mockFunction.mockReturnValue(42); // 調用模擬函數 const result = mockFunction(); // 測試模擬函數被調用一次 expect(mockFunction).toBeCalledTimes(1); // 測試模擬函數返回值為 42 expect(result).toBe(42); 結語 關於 Jest 筆記會持續更新～\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/11/react-jest/","tags":["React.js","Jest"],"title":"Use Jest"},{"categories":["Notes"],"contents":"前言 React Testing Enzyme 主要介紹幾個方法：shallow、render、mount。\n函數 渲染範圍 子元件渲染 事件模擬 shallow 只渲染元件本身 不渲染子元件 支援事件模擬 render 產生靜態 HTML 字串 不在真實 DOM 渲染 不支援事件模擬 mount 渲染整個 React 樹 渲染所有子元件 支援事件模擬 範例 使用shallow函數： 情境：測試一個 React 按鈕元件的點擊事件處理，而不需要渲染其子元件。\nimport React from \u0026#39;react\u0026#39;; import { shallow } from \u0026#39;enzyme\u0026#39;; const MyButton = ({ onClick }) =\u0026gt; ( \u0026lt;button onClick={onClick}\u0026gt;Click me\u0026lt;/button\u0026gt; ); describe(\u0026#39;MyButton\u0026#39;, () =\u0026gt; { it(\u0026#39;should handle click event using shallow\u0026#39;, () =\u0026gt; { const onClickMock = jest.fn(); const wrapper = shallow(\u0026lt;MyButton onClick={onClickMock} /\u0026gt;); wrapper.find(\u0026#39;button\u0026#39;).simulate(\u0026#39;click\u0026#39;); expect(onClickMock).toHaveBeenCalled(); }); }); 使用render函數： 情境：測試一個 React 文字元件的渲染結果，並確保它以特定方式呈現，但不需要模擬事件處理。\nimport React from \u0026#39;react\u0026#39;; import { render } from \u0026#39;enzyme\u0026#39;; const Greeting = ({ name }) =\u0026gt; ( \u0026lt;div\u0026gt;Hello, {name}!\u0026lt;/div\u0026gt; ); describe(\u0026#39;Greeting\u0026#39;, () =\u0026gt; { it(\u0026#39;should render greeting message using render\u0026#39;, () =\u0026gt; { const renderedComponent = render(\u0026lt;Greeting name=\u0026#34;John\u0026#34; /\u0026gt;); expect(renderedComponent.text()).toBe(\u0026#39;Hello, John!\u0026#39;); }); }); 使用mount函數： 情境：測試一個包含多個子元件的 React 表單，包括模擬事件處理和子元件的互動。\nimport React from \u0026#39;react\u0026#39;; import { mount } from \u0026#39;enzyme\u0026#39;; const Form = ({ onSubmit }) =\u0026gt; ( \u0026lt;form onSubmit={onSubmit}\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ); describe(\u0026#39;Form\u0026#39;, () =\u0026gt; { it(\u0026#39;should handle form submission using mount\u0026#39;, () =\u0026gt; { const onSubmitMock = jest.fn(); const wrapper = mount(\u0026lt;Form onSubmit={onSubmitMock} /\u0026gt;); const usernameInput = wrapper.find(\u0026#39;input[name=\u0026#34;username\u0026#34;]\u0026#39;); const passwordInput = wrapper.find(\u0026#39;input[name=\u0026#34;password\u0026#34;]\u0026#39;); const submitButton = wrapper.find(\u0026#39;button\u0026#39;); usernameInput.simulate(\u0026#39;change\u0026#39;, { target: { value: \u0026#39;user123\u0026#39; } }); passwordInput.simulate(\u0026#39;change\u0026#39;, { target: { value: \u0026#39;password123\u0026#39; } }); submitButton.simulate(\u0026#39;submit\u0026#39;); expect(onSubmitMock).toHaveBeenCalledWith({ username: \u0026#39;user123\u0026#39;, password: \u0026#39;password123\u0026#39;, }); }); }); 結語 總結一下：\nshallow 函數：\n使用 shallow 函數時，它只渲染被測試元件本身，不渲染其子元件。 主要用於測試被測試元件的行為，而不關心子元件的情況。 可以模擬事件處理，用於測試點擊事件、輸入事件等。 render 函數：\nrender 函數將元件渲染成靜態 HTML 字串，但不在真實 DOM 中渲染。 主要用於測試元件的渲染結果，以及進行快照測試。 不支援事件模擬，因為它不在真實 DOM 中渲染。 mount 函數：\n使用 mount 函數時，它會渲染整個 React 樹，包括子元件。 主要用於進行完整的測試，包括事件處理、互動和子元件渲染的情況。 可以模擬事件處理，用於測試點擊事件、輸入事件等。 可以根據測試需求選擇適當的函數，以確保測試覆蓋到你的應用程式中不同情境下的需求。\n以上是我在工作期間整理Enzyme幾個基本用法。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/11/react-testing-enzyme/","tags":["React.js","Jest","Testing Library"],"title":"React Testing Enzyme"},{"categories":["Notes"],"contents":"前言 React Testing Library 主要提供幾個方法：render、fireEvent、screen、waitFor。\n前置設定需搭配 @testing-library/jest-dom。\n什麼時候該用此 Library 可參考官方Solution render 用於渲染 React 組件到虛擬 DOM 中，並返回一個包含渲染結果的容器對象。\nfireEvent 用於模擬 DOM 事件，例如點擊、輸入文字、提交表單等。這可用於觸發元素上的事件，以模擬使用者操作。\nscreen 提供了一組方法來查找 DOM 元素，以進行測試操作。\nwaitFor 用於等待異步操作完成，通常用於等待數據載入、渲染完成或狀態更新。\n範例 以下測試測試按鈕點擊後是否正確顯示文字流程。\n// ButtonComponent.js import React, { useState } from \u0026#39;react\u0026#39;; function ButtonComponent() { const [isClicked, setIsClicked] = useState(false); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setIsClicked(true)}\u0026gt;Click Me\u0026lt;/button\u0026gt; {isClicked \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Button was clicked!\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } export default ButtonComponent; import React from \u0026#39;react\u0026#39;; import { render, fireEvent, screen, waitFor } from \u0026#39;@testing-library/react\u0026#39;; import ButtonComponent from \u0026#39;./ButtonComponent\u0026#39;; test(\u0026#39;測試按鈕點擊後是否正確顯示文字\u0026#39;, async () =\u0026gt; { // 渲染組件 render(\u0026lt;ButtonComponent /\u0026gt;); // 首先確保文字元素不可見 expect(screen.queryByText(\u0026#39;Button was clicked!\u0026#39;)).toBeNull(); // 找到按鈕元素 const button = screen.getByText(\u0026#39;Click Me\u0026#39;); // 模擬點擊按鈕 fireEvent.click(button); // 使用 waitFor 等待直到文字元素出現 await waitFor(() =\u0026gt; { expect(screen.getByText(\u0026#39;Button was clicked!\u0026#39;)).toBeInTheDocument(); }); }); 結語 以上是我在工作期間整理react-testing-library幾個基本用法，如果需更深入了解可到官方文件學習。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/11/react-testing-library/","tags":["React.js","Jest","Testing Library"],"title":"React Testing Library"},{"categories":["Notes"],"contents":"前言 React Hooks Testing Library 主要提供三個方法：renderHook、act、cleanup。\n什麼時候該用此 Library 官方Solution 使用\n當寫一個函式庫，且 Hooks 並不是只在某個對應的元件中被使用 Hook 非常複雜，很難透過組件互動進行測試 不要使用\nHook 只給某對應的元件使用時 Hook 非常容易測試，只需要直接針對元件進行測試即可 renderHook 如果要取得 hook 的回傳值，可透過result.current取得當前最新的值。\nact 當 hook 內部 state 改變時（例如，setXXX），需要把這個方法包在 act 後才加以呼叫。\ncleanup 用來清理測試環境，用法cleanup()。\n範例 測試useUIState的初始狀態和狀態更新時，是否都可正常工作。\n以下測試三種狀態pageFlow、isLoading、isPending。\n// useUIState.js import { useReducer } from \u0026#39;react\u0026#39; // 定義操作類型 const ACTIONS = { SET_PAGE_FLOW: \u0026#39;SET_PAGE_FLOW\u0026#39;, SET_IS_LOADING: \u0026#39;SET_IS_LOADING\u0026#39;, SET_IS_PENDING: \u0026#39;SET_IS_PENDING\u0026#39; } // 初始化狀態 const getInitState = props =\u0026gt; { const { match: { params: { phase } } } = props return { pageFlow: phase, isLoading: false, isPending: false } } // 自定義 Hook const useUIState = props =\u0026gt; { const reducer = (state, action) =\u0026gt; { const { type, payload } = action switch (type) { case ACTIONS.SET_PAGE_FLOW: return { ...state, pageFlow: payload } case ACTIONS.SET_IS_LOADING: return { ...state, isLoading: payload } case ACTIONS.SET_IS_PENDING: return { ...state, isPending: payload } default: return state } } // 使用 useReducer 管理狀態 const [state, dispatch] = useReducer(reducer, props, getInitState) // dispatch 觸發狀態更新操作 const setPageFlow = pageFlow =\u0026gt; dispatch({ type: ACTIONS.SET_PAGE_FLOW, payload: pageFlow }) const setIsLoading = isLoading =\u0026gt; dispatch({ type: ACTIONS.SET_IS_LOADING, payload: isLoading }) const setIsPending = isPending =\u0026gt; dispatch({ type: ACTIONS.SET_IS_PENDING, payload: isPending }) const actions = { setPageFlow, setIsLoading, setIsPending } return { state, actions } } export default useUIState 可以看到第一個check initial state測試，假設renderHook取得props回傳值，並確認result.current.state是跟預期initialState相同。\n而第二個test actions works測試，透過act模擬更新狀態，最後檢查當前狀態是否跟updatedState相同。\n// useUIState.test.js import { renderHook, act } from \u0026#39;@testing-library/react-hooks\u0026#39; import useUIState from \u0026#39;./useUIState\u0026#39; // flowTypes export const PAGE_FLOW = { INITIAL: \u0026#39;initial\u0026#39;, EDIT: \u0026#39;edit\u0026#39;, CONFIRM: \u0026#39;confirm\u0026#39;, SUCCESS: \u0026#39;success\u0026#39;, ERROR: \u0026#39;error\u0026#39; } describe(\u0026#39;useUIState\u0026#39;, () =\u0026gt; { const props = { match: { params: { phase: PAGE_FLOW.INITIAL } } } it(\u0026#39;check initial state\u0026#39;, () =\u0026gt; { const { result } = renderHook(() =\u0026gt; useUIState(props)) const initialState = { pageFlow: PAGE_FLOW.INITIAL, isLoading: false, isPending: false } expect(result.current.state).toEqual(initialState) }) it(\u0026#39;test actions works\u0026#39;, () =\u0026gt; { const { result } = renderHook(() =\u0026gt; useUIState(props)) const updatedState = { pageFlow: PAGE_FLOW.ERROR, isLoading: true, isPending: true } act(() =\u0026gt; { result.current.actions.setIsLoading(updatedState.isLoading) result.current.actions.setIsPending(updatedState.isPending) result.current.actions.setPageFlow(updatedState.pageFlow) }) expect(result.current.state).toEqual(updatedState) }) }) 結語 以上是我在工作期間整理react-hooks-testing-library幾個基本用法，如果需更深入了解可到官方文件學習。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/11/react-hooks-testing-library/","tags":["React.js","Jest","Testing Library"],"title":"React Hooks Testing Library"},{"categories":["Notes"],"contents":"前言 這是一個物業管理，其中也有硬體端整合，這套系統從零到現在正式上線，我全程參與，包含事前規劃流程設計、UI討論。\n技術架構 前後端分離，前端用 React.js 開發及 icejs+(fusion/antd)UI，完成管理者後台介面\u0008及 APP 使用者介面 使用 Feathers 框架創建 REST API 和 WebSocket 與後端溝通，帳號權限處理、帳號登入登出機制 資料庫使用 MongoDB 使用 Docker-compose 部屬到公司購買實體主機 功能介紹 使用者APP介面 帳號設置：綁定社區、QRCode掃描或帳密登入建立帳號。\n個人首頁：平台手冊下載、各項功能Icon(點擊可至該頁面)、推播紀錄通知、推播紀錄通知、帳號設定、畫板(可下載or儲存照片)。\n通知訊息：公告、行事曆、訪客、包裹 、寄物、投票、報修、公設預約、BA系統 等\u0026hellip;通知。\n個人設置：住戶開通條碼、用戶頭像、暱稱、密碼修改。\n系統設置：各項推播設置、一鍵推播。\n公告事項：類別篩選、公告細項頁、檔案及圖片preview及download。\n行事曆：行事曆UI、檔案及圖片preview及download。\n郵件包裹：查看包裹紀錄、條碼(可給警衛掃描)、條件篩選。\n寄物管理：查看寄物紀錄、條件篩選。\n公設預約：公設資訊、公設預約表單、紀錄查詢、取消預約。\n訪客門禁：訪客預約表單、紀錄查詢、取消登記、轉發Line。\n投票活動：投票資訊、checkbox選項、投票統計。\n報修服務：新增報修表單、檔案上傳、狀態進度、回覆內容。\n瓦斯抄錶：抄錶登記表單、檔案上傳。\n意見反應：新增表單、檔案上傳。\n智慧信箱：查看信箱狀態、遠端開啟信箱。\n家庭保全：開啟關閉保全。\n身體量測：個人血壓、身高體重資料、圖表統計。\nBA 系統：遠端開關電燈、窗簾、門口機、大門、信箱、BA裝置\u0026hellip;等。\n汽車充電樁：顯示圖表、紀錄等。\n智慧建築專區：各文件顯示。\n後台管理 (CRUD＝指列表新增、查詢、更新、刪除的功能) 首頁：下載教學手冊、推播紀錄通知、功能選單、帳號設定、全屏切換。\n個人設置：可更換大頭貼、暱稱、重設密碼。\n系統設置：各項功能推播設置。\n登入註冊：帳密登入、註冊帳號。\n通知訊息：通知紀錄、查看、已讀模式。\n公告事項：公告(CRUD)、置頂、推播各戶(棟)功能、類別搜尋。\n行事曆：行事曆(CRUD)、推播。\n郵件包裹：包裹(CRUD)、領取包裹方式(掃描APP條碼、磁扣、卡片)、拍照、簽名、通知住戶(APP通知)、退貨、紀錄。\n寄物管理：寄物(CRUD)、領取包裹方式(掃描APP條碼、磁扣、卡片)、通知住戶 (APP通知)、紀錄。\n訪客管理：訪客(CRUD)、訪客統計、訪客車牌管理、訪客辨識管理、訪客卡管理、 訪客進場離開開關。\n公設預約：公設(CRUD)、紀錄、時段預約、計次預約。\n投票活動：投票(CRUD)、設定問題選項。\n報修服務：報修(CRUD)、報修進度、回報表單、通知住戶。\n瓦斯抄錶：抄錶(CRUD)、下載住戶抄錶資料。\n意見反應：意見(CRUD)、通知住戶、回覆進度內容。\n智慧信箱：各住戶紀錄、開啟信箱、投信狀態。\nBA 系統：裝置(CRUD)、紀錄、匯出匯入Excel、門禁權限管理。\n財務管理：住戶財務、社區財務、下載報表、產生帳單(未開發完成)。\n智慧建築專區：資產管理、效能管理、維運管理、組織管理、文件檔案管理。\n社區管理：戶號(CRUD)、匯入匯出資料、下載範例表單、下載QR Code、住戶開通、社區基本資料、訊息推播。\n帳號管理：使用者帳號(CRUD)、開通帳號、權限設定、頁面權限設定。\n結語 從 O 到上線的專案做完蠻有成就感🥰\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/11/property-notes/","tags":["React.js","Feathers","MongoDB"],"title":"物業系統"},{"categories":["Portfolio"],"contents":"前言 是一個在「資策會」做的專題，從規劃、設計、實作、發表，總共花了一個多月時程。\n使用技術及工具 設計/原形工具：Illustrator、Adobe XD 前端技術：HTML、CSS、SCSS、JavaScript 前端框架：React.js 後端技術：Node.js、Express 資料庫運用：MySQL 版本控制：GitHub 套件技術：axios、node-sass、react-redux、redux-persist、redux-saga、reselect 編輯器技術： VS Code 功能說明： 首頁 會員登入註冊 會員中心系統 商城\u0026amp;購物車系統 結帳\u0026amp;訂單系統 課程預約系統 教練中心系統 心得討論區系統 客服中心系統 網站功能介紹 首頁 會員登入註冊 會員中心系統 登入後，即可進入會員中⼼，提供會員資料修改並管理購買清單以及查詢已報名之課程、⽂章管理以及客訴紀錄。\n商城\u0026amp;購物車系統 提供商品的篩選以及價格排序的功能。\n商品點擊提供更細項內容。\n可加入收藏清單及購物車。\n結帳\u0026amp;訂單系統 結帳分為確認清單、填寫付款方式及完成頁。\n可查看訂購紀錄。\n課程預約系統 可預約課程、資訊瀏覽並有人數額滿限制提示。\n教練中心系統 提供上下架課程功能。\n心得討論區系統 提供發表文章、篩選文章、留言、按讚等功能。\n客服中心系統 Q\u0026amp;A瀏覽、客訴表單、即時問答等功能。\n結語 以下是我的分工\n前端：討論區首頁、文章細節頁、文章上下架及編輯頁、會員管理文章紀錄\n後端：MySQL⽂章資料表設計及會員、⽂章API及路由設計\n其他：專題簡報製作、整合組員程式碼、UI設計\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/11/portfolio-wow-fit/","tags":["React.js","Redux","MySQL","Node.js"],"title":"複合型健身房官方網站「WoW FIT」"},{"categories":["Portfolio"],"contents":"前言 這是我練習用 React Native 來寫 App，並使用 Expo 呈現\n以下用 Expo 線上工具 Demo 進到 Expo 可以針對不同 Device 查案 以下環境是 iOS 遊戲規則：直到全部配對成功\n結語 重 0 開始建置 React Native ，讓我更清楚架構。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/11/portfolio-match-game/","tags":["React Native"],"title":"Matching Game"},{"categories":["Portfolio"],"contents":"前言 當時在前公司訂便當的時候，都要跑去每個人座位詢問，挺麻煩的!\n於是決定與一位後端同仁一起搭建午餐機器人。\n架構 這邊我是用 Feathers + MongoDB Atlas 部署到 Render 作品\n後台介面：Feathers、React 和 Feathers Socket.IO 創建一個實時應用程序，並實現數據的即時更新。 LineBot：設定 Channel ID、Channel Secret\u0026hellip;等必要資訊，並 Webhook 路由及處理 LineBot 事件 測試環境用 Ngrok 建立一個 LineBot Webhook 的 HTTPS URL 步驟 1：在 Ngrok官網 創建一個帳戶 步驟 2：執行 Ngrok 下載並解壓縮後你會獲得一個 ngrok 的執行檔。\nMac 環境變數設定：需要將 ngrok 執行檔拖曳到 /usr/local/bin/ 資料夾內。\n切換到/bin目錄 將 Webhook 轉發到本地端口（例如 3030）。\n啟動服務 可以看到 Forwarding 有一個 https 服務，到時候就可以貼到 LineBot Webhook。\nLineBot設定就不再探討，可以去我寫的 LineBot 關鍵字儲存查詢 文章看\n午餐機器人及後台管理 Demo 可在後台新建菜單 這時候可以看見LineBot輸入吃(這邊是我們自己下的指令)，就會產生訂單 接著按下開始訂單，就依照機器人回覆輸入相對應文字 後台介面就可以看到在 LineBot 輸入的資訊了 也可以對成員新增、編輯、刪除、查詢 當同事過來給當天值日生繳錢時，就可以按下付錢，後台頁面也會統計誰沒繳方便查詢 結語 以上就是我們替同事製作的午餐 Bot，大家只要加官方帳號，動手輸入一些指令就能輕鬆訂便當，真的方便許多🎉\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/11/portfolio-lunch-linebot/","tags":["LineBot","Line","Ngrok","React.js","Feathers"],"title":"午餐機器人"},{"categories":["Portfolio"],"contents":"前言 之前在前公司有用到 Line shareTargetPicker API 的應用，用來發送訪客 QR code 給 Line 好友，這邊做一個簡單 Demo，單純轉發當前 URL 給好友。\nLine LIFF ShareTargetPicker 教學 步驟 1：進到 developerse官網 建立 channel 選擇 Products，請選擇LINE Login，然後Create a new channel\n步驟 2：建立 LIFF 這時點選頁籤LIFF按下Add。\n以下說明 LIFF 表單\nSize：這一項有三個值 Full、Tall、Compact，說明 LINE 打開 LIFF 時，他的大小要多大。 要注意的是，分享的按鈕只會在「Full」這個 Size 出現。\nEndpoint URL ：使用者點擊了 LIFF 的連結，實際上 LIFF 是開啟了哪個頁面。\nScopes ：指的是我們想要取哪些資料，「chat_message.write」，這項是如果要用到主動幫使用者發訊息的 sendMessages 函式時，這邊就必須打勾，不然 sendMessages 就無法使用。\nAdd friend option ：當使用者要登入我們建立的 LIFF 時，要怎麼推薦他加入我們的 LINE。\nScan QR ：指要不要使用 LIFF 的打開 QR code 掃描器功能。\n步驟 3：建立 LIFF 完成 建立完成後記得勾選shareTargetPicker，這項功能是主動讓使用者發送我們指定的訊息給他的好友。\nLIFF ID這個要先記起來，之後寫 JS 用到。\n步驟 4：LIFF 轉成公開 進到 LINE Developers 的後台，進到我們創建的 LIFF，會有一個Developing的按鈕，需要按下Publish就會轉成公開\n程式碼參考範例 Demo 影片 結語 主要是可以讓使用者用 Line 就可以快速分享該頁面。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/10/portfolio-line-sharetargetpicker/","tags":["Line"],"title":"Line LIFF ShareTargetPicker"},{"categories":["Portfolio"],"contents":"前言 依照個人喜好做出各種風格的機器人像是 AI 聊天，接收到的文字另存至資料庫等\n建立 Line bot 步驟 1：在 LINE Developers 登入自己Line帳號 步驟 2：建立 line 頻道 選擇 Messaging API\n步驟 3：將帳號加為好友 建立好 channel，可在第二個頁籤Messaging API看到Bot basic ID，這就是新增好友的 ID，也可以掃QR code。\n步驟 4：設定 Webhook 往下滑會看到Webhook settings，把Use webhook打開，上方的 URL可以先不輸入，等等再回來設定。\n步驟 5：記下程式連接Bot必要的密鑰 這兩個到時候我是添加到程式中.env的設定。\nBasic settings — Channel secret Messaging API — Channel access token 步驟 6：設定自動回覆及打招呼 在Messaging API頁籤拉到下面會看到LINE Official Account features，點選Auto-reply messages右邊的編輯可以設定。\n回應設定就看個人需求，我這邊都是打開。\n建立聊天機器人專案 這邊我是用 Node.js + MongoDB Atlas 部署到 Render\n以下是撰寫 Node.js 程式筆記 步驟 1：安裝@line/bot-sdk這個套件，並在專案底下建立一個app.js的檔案 npm i @line/bot-sdk express dotenv 步驟 2：撰寫 LINE Bot 不外乎前面就是引入@line/bot-sdk、express與dotenv這三個套件，Line 官方有提供範例程式碼。\n步驟 3：建立.env，並寫下創建 LineBot 的密鑰channelSecret及channelAccessToken。 部署至 Render 步驟 1：到官網註冊，並 Connect GitHub 步驟 2：選擇要部署的專案 點選Web Services\n設置Configure account，選擇 LineBot 專案\n步驟 3：Connect 要部署的專案 點擊Connect\n步驟 4：填寫部署資訊 步驟 5：選擇收費方案 這裡我選Free\n步驟 6：「Advanced」區塊填入環境變數 點一下「Add Environment Variable」，依照欄位填入\n步驟 7：Create Web Service 這時候就會開始進行部署\n回到 line 設定 webhook 到dashboard選擇想要的services name，進去後左上角會看見一串URL，這就是需要設定在 line webhook。\n記得要加上/callback。\n小皮妞Bot Demo 打開指令介紹：** 增加紀錄：@標題@內容 搜詢當下關鍵字：@@關鍵字 刪除當下第N筆文章：@$N 輸出當下\u0026quot;文章編號(第N*10筆)：$$$N 輸出當下第N筆文章：$$N 輸出自己\u0026quot;文章編號(第N*10筆)：$$$myN 可以群聊針對自己文章查詢 輸出不存在指令：可以隨便打測試 結語 Heroku 轉移至 Fly.io，讓我的小皮妞Bot復活，但莫名其妙被多收錢，因此再轉移至 Render。\n而 Render 優點：\n有免費計畫，且不用先綁信用卡，用起來比較安心\n每個月免費 500 分鐘建構，和 450 小時免費使用時數\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/10/portfolio-qq-linebot/","tags":["Render","LineBot","Line"],"title":"LineBot 關鍵字儲存查詢"},{"categories":["Notes"],"contents":"前言 由於 Heroku 取消了免費的服務\u0026hellip;個人作品都壞掉了，因此換成 Fly.io 部署\n在 Ｆly.io 建立專案 步驟 1：安裝 flyctl 這裡教學以 macOS 為例，可參考 官網 。\nbrew install flyctl 步驟 2：註冊並登入 會彈出瀏覽器視窗，可以連結 GitHub 帳號。\nflyctl auth signup flyctl auth login 步驟 3：啟動既有專案 cd 到專案後，下flyctl launch，輸入專案的名稱。\n選擇 server region，我這邊選擇香港(Hong Kong)。\n注意帳號一定要綁定信用卡才行用 會問需要使用 DB 嗎?這裡就看需求了(剛好我這個專案需要)，我就選 Yes 。\n步驟 4：開始部署 flyctl deploy 這時在終端機看到succeeded代表完成部署🎉\n可以在終端機下flyctl logs除錯\n步驟 5：訪問自己網站 可以從https://fly.io/dashboard查看所建立的 APP ，裡面會有 Hostname。\n結語 Heroku 轉移至 Fly.io，讓我的小皮妞Bot復活，但要小心不要亂搞避免產生額外費用參考。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/10/heroku-to-flyio/","tags":["Heroku","Fly.io"],"title":"Heroku 轉移至 Fly.io "},{"categories":["Notes"],"contents":"前言 在寫 Markdown 文章時候，想要為 link 添加 {target=\u0026quot;_blank\u0026quot;} 屬性參考文章，但卻起不了作用(會變字串)。\n這是一個連結[網站](http://example.com){target=\u0026#34;_blank\u0026#34;}的示例。 這是在猜想可能是 Hugo 版本不相容，就用上網找了解法，他說：Hugo 的安全模式可能會阻止執行 JavaScript。在安全模式下，Hugo 默認會禁用 JavaScript 和某些 HTML 標籤以增加網站的安全性。\n他說可以在config.toml進行配置，禁用 Hugo 的安全模式。\n[markup] [markup.goldmark] [markup.goldmark.renderer] unsafe = true 但這個方法是可以執行另開網站，但會有安全性風險，所以我就棄用了。\n解決方案：在 Markdown 添加 ShortCodes 步驟 1：在themes/layouts底下新增一個資料夾shortcodes，並建立target-blank.html 並添加以下內容，這個 ShortCode 將創建target=\u0026quot;_blank\u0026quot;屬性，並帶兩個參數。\n.Get \u0026quot;url\u0026quot; 用來指定 Link 的 URL。 .Inner 用來指定 Link 的 文本。 \u0026lt;a href=\u0026#34;{{ .Get \u0026#34;url\u0026#34; }}\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;{{ .Inner }}\u0026lt;/a\u0026gt; 步驟 2：加在想要 Markdown 中 注意 shortCode 命名盡量跟 html 文件名保持ㄧ至。\n結語 看完以上內容，可以完成解決 Hugo Markdown 連結無法另開網頁問題，如果以上有問題歡迎討論。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/10/target-blank-logo/","tags":["Hugo"],"title":"解決 Hugo Markdown 連結無法另開網頁問題"},{"categories":["Tech"],"contents":"前言 SEO是什麼？： SEO 代表搜索引擎優化，它是一系列策略和技術，用於提高網站在搜索引擎中的排名。\n為什麼它如此重要？： SEO 是吸引有機流量、提高品牌知名度、增加潛在客戶和改善線上業務成功的關鍵因素。\n本文的目標：以下是使用 Hugo 產生靜態網頁的 SEO 最佳化建議。\n設定頁面關鍵字 步驟 1：在該篇文章 Markdown 添加 keywords keywords: - Hugo SEO - 靜態網頁SEO - SEO最佳化建議 - 搜尋引擎優化 - 網站排名 步驟 2：添加 meta 標籤 這邊我是加在themes/layouts/partials/head.html裏面。\n{{ with .Params.keywords }} \u0026lt;meta name=\u0026#34;keywords\u0026#34; content=\u0026#34;{{ delimit . \u0026#34;, \u0026#34; }}\u0026#34;\u0026gt; {{ end }} {{ with .Params.keywords }}這是一個條件語句，检查文章 Markdown 文件中是否存在keywords字段 ，然而delimit用逗號和空格分隔成一個字符串。\n步驟 3：打包後看 html 結果，這樣就完成頁面關鍵字設定 \u0026lt;meta name=\u0026#34;keywords\u0026#34; content=\u0026#34;Hugo SEO, 靜態網頁SEO, SEO最佳化建議, 搜尋引擎優化, 網站排名\u0026#34;\u0026gt; 設定頁面標題 步驟 1：在該篇文章 Markdown 添加 title title: \u0026#34;Hugo SEO（搜尋引擎優化）實踐\u0026#34; 步驟 2：添加 title 標籤 這邊我是加在themes/layouts/partials/head.html裏面。\n這段意思是：如果當前頁面不是首頁，則會在標題中包括網站的名稱，以區分首頁和其他頁面的標題顯示方式。如果當前頁面是首頁，則只顯示頁面的標題，不包括網站名稱。 \u0026lt;title\u0026gt;{{ $isHomePage := eq .Title .Site.Title }}{{ .Title }}{{ if eq $isHomePage false }} - {{ .Site.Title }}{{ end }}\u0026lt;/title\u0026gt; 步驟 3：打包後看 html 結果，這樣就完成頁面標題設定 \u0026lt;title\u0026gt;Hugo SEO（搜尋引擎優化）實踐\u0026lt;/title\u0026gt; 設定頁面描述 步驟 1：在該篇文章 Markdown 添加 description description: \u0026#34;Hugo 產生靜態網頁的 SEO 最佳化建議\u0026#34; 步驟 2：添加 meta 標籤 這邊我是加在themes/layouts/partials/head.html裏面。\n這段意思是同頁面標題 \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;{{ with .Description }}{{ . }}{{ else }}{{ with .Site.Params.description }}{{ . }}{{ end }}{{ end }}\u0026#34;\u0026gt; 步驟 3：打包後看 html 結果，這樣就完成頁面描述設定 \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;Hugo 產生靜態網頁的 SEO 最佳化建議\u0026#34;\u0026gt; 結語 正確使用關鍵字可以提高您的文章在搜尋引擎中的排名，但不要忘記提供高質量的內容和有價值的信息。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/10/hugo-seo/","tags":["Hugo","SEO"],"title":"Hugo SEO（搜尋引擎優化）實踐"},{"categories":["Tech"],"contents":"前言 想要針對各特定頁面觸發事件和追蹤點擊事件，該怎麼做？\n特定頁面觸發事件 步驟 1：建立事件 可到 Google Analytics 點選左下角齒輪管理/資源設定/事件創建。\n這邊舉例/about頁面事件\n可以去 Debug View 偵測事件\n步驟 2：新增轉換 可到 Google Analytics 點選左下角齒輪管理/資源設定/轉換。\n這邊舉例about_me_page事件名稱轉換\n追蹤點擊事件 步驟 1：建立事件 同上，在資源事件設定。\n這邊舉例點擊Social/github圖示事件\n步驟 2：新增轉換 同上，在資源轉換設定。\n進階實作-如何在個人網站中自訂事件發送給GA 在 Hugo 程式碼加入 gTag Event，這邊我用點擊Know More按鈕作為 Demo，只要在程式中添加以下圖是代碼就可以發事件給 GA。\n當使用者點擊具有 \u0026ldquo;knowMoreButton\u0026rdquo; ID 的按鈕時，這段 JavaScript 代碼會觸發一個自定義事件，並將事件數據發送到 Google Analytics。這個事件包括事件名稱（\u0026ldquo;know_more_button_click\u0026rdquo;）、事件類別（\u0026ldquo;按鈕點擊\u0026rdquo;）、事件標籤（\u0026ldquo;點擊了更多按鈕\u0026rdquo;）和一個可選的值（1，用於量化事件的價值）。這有助於跟踪 Google Analytics 中使用者點擊 \u0026ldquo;Know More\u0026rdquo; 按鈕的互動。\n這時在個人網頁觸發幾次Know More事件，可以在 Google Analytics 即時報表上看到數據了。\n結語 透過自訂事件\u0026amp;轉換更能追蹤自己想要的數據了🎉\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/10/google-analytics-setting/","tags":["GA","Google"],"title":"如何在 Google Analytics 4 自訂事件\u0026轉換"},{"categories":["Notes"],"contents":"前言 介紹通用版 GA 與 GA4 差異 通用版 GA：追蹤網頁資料為核心。\nGA4：事件為核心。\n這個簡單的表格比較了通用版 GA 和 GA4 在數據收集方式、用戶跟踪、報告功能、用戶隱私和未來支持等方面的主要差異。\n網站流量 5 大面向 訪客量：每段時間有多少訪客量。\n相關性：多少比例訪客是目標客群。\n參與度：訪客在網站上行為。\n持續性：訪客的回鍋。\n收益：這些訪客量是否帶來轉換價值或收益。\nGoogle Analytics 帳戶設定 步驟 1：Google 信號啟用 在資源設定/資料收集的 Google 信號資料收集把它打開。\n步驟 2：啟用加強評估 打開後 Google 會自動評估網站上的互動和內容，並建立成事件。\n步驟 3：事件保留時間 GA4 預設保留 2 個月，建議調整成 14 個月。\n步驟 4：歸因分析設定 報表歸因模式及回朔期調整紅匡預設內容即可。\n步驟 5：如何設定網域然後做跨網域評估 可讓跨網域評估成效，並進一步定義網站上的哪些連結，在使用加強評估時不會觸發外連點擊事件。\n例如：主網站＋另1個獨立個網域，想要合併評估成效\n如何設定：資料串流(選擇你的資料)/Google代碼(進行代碼設定)/設定網域/跨網域連結設定\n步驟 6：排除非必要流量 如何設定：資料串流(選擇你的資料)/Google代碼(進行代碼設定)/列出不適用的參照連結網址\n步驟 7：Search Console 連結 進到 Search Console 按下連結選擇帳號即可。\nGA4 事件介紹 根據現有事件，建立新事件 特定頁面：\nevent_name = page_view\npage_location 包含 xxx\n點擊事件：\nevent_name = click\nlink_url 包含 xxx\n根據值觸發事件 purchase 事件且值至少為 1000\nevent_name = purchase\nvalue 大於或等於 1000\n參數設定有打勾從來源複製事件參數，可以沿用事件既有參數配置\n可以用GA4 Debug View，測試事件\n結語 透過此篇介紹來更加了解 GA4。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/10/google-analytics-introduction/","tags":["GA","Google"],"title":"Google Analytics 4 介紹"},{"categories":["Tech"],"contents":"前言 目的想在 Google 被搜尋到我的個人 Blog\n開始添加 Google Search Console 步驟 1：點擊 Google Search Console，後按下「立即開始」，就可以開始設定 步驟 2：選取資源類型 點擊網址前置字元區塊，輸入個人網站網址後，按繼續，這時如果有設定好 GA，他這邊會透過 GA 去驗證你的網站，點擊前往資源。\n步驟 3：新增 Sitemap 點選側邊選單 Sitemap 填寫網址，輸入sitemap.xml即可。\nSitemap：會把網站所有頁面列出來在這個檔案裡，在把 Sitemap 這個檔案上傳到 Google Search Console上，Google 會將這些頁面存到 Google 搜尋引擎裡面，這樣別人在 Google 搜尋時就能找到你的個人網站了。 實際會在打包後產出public/sitemap.xml檔案裡，這些檔案會列出個人網站所有頁面、每個頁面修改時間，到時候會被 Google Search 就能找到。\n步驟 4：檢查 Blog 能夠被 Google 搜尋到 方法：在 Google Search 輸入site:個人網站網址\nsite:ChrisLinOvO.github.io 剛建立好可能要等明天才搜尋的到\n也可以 Google Search Console 手動建立索引，要求指定頁面加到 Google 搜尋引擎裡面\n結語 看完以上內容，趕快加入 Google Search Console，可以輕鬆查看在 Google Search 數據及報表，若要提升搜尋結果排行較前面，可進行 SEO 優化，之後會再做介紹。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/10/google-search-console/","tags":["Google"],"title":"添加 Google Search Console"},{"categories":["Tech"],"contents":"前言 想查看使用者對於我的網站網站互動\n開始添加 Google Analytics 步驟 1：點擊 Google Analytics，後按下「開始測量」，就可以開始設定 步驟 2：建立帳戶 輸入帳戶名稱後，往下拉下面不用改，按下一步。\n步驟 3：建立資源 輸入屬性名稱，下面報表時區、幣別可以不用改，按下一步。\n步驟 4：選擇商家資訊 選擇產業類別(平常寫的文章什麼類型)，按下一步。\n步驟 5：選擇業務目標 這裡我是選擇「產生待開發客戶」、「檢視使用者行為」，這兩個都可以透過事件追蹤功能來記錄關鍵的互動，按下建立。\n步驟 6：著手收集資料 點選網站平台後，設定您的網頁串流，輸入網站網址及名稱後，建立串流。\n步驟 7：加入 Google 代碼至主題 建立完成後會出現「網頁串流詳情」，這時按下「查看代碼操作說明」，會出現手動安裝代碼，\n將代碼貼到themes/layouts/partials/head.hml裡面即可。\n如果是下載比較新版的主題，要把舊版 GA 設定刪除，需在head.html原本設定的 GA 以及config.toml裡面googleAnalitycsID移除\n步驟 8：確認 GA 與個人網站連結成功 結語 看完以上內容，可以完成加入 GA4，至於 GA4 的靈魂「事件」可能研究過後整理一篇文章做介紹。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/10/hugo-google-analytics/","tags":["GA","Google","Hugo"],"title":"Hugo 添加 Google Analytics"},{"categories":["Tech"],"contents":"前言 Utterances 是一種基於 GitHub Issues 的評論系統。它允許在靜態網站中嵌入一個評論框，並將評論存儲在與自己的 GitHub 存儲庫相關聯的 Issues 中。\n安裝 Utterances 及配置 步驟 1：到安裝頁面後點選 Install 步驟 2：選擇要安裝 Utterances 的 GitHub Repository 步驟 3：添加配置至程式碼中 可由官網進行配置\n設置 repo 名稱 選擇訪客留言 issue 名稱 選擇主題 可複製產出的代碼貼在自己的 repo 這邊我是放在themes/layouts/partials資料夾建立一個comments.html，把生成的代碼複製過去。\n\u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;ChrisLinOvO/ChrisLinOvO.github.io\u0026#34; issue-term=\u0026#34;pathname\u0026#34; theme=\u0026#34;github-light\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async \u0026gt;\u0026lt;/script\u0026gt; 若每篇文章最底下要加評論，只需要在themes/layouts/_default/single.html裡加上\n{{ partial \u0026#34;comments.html\u0026#34; . }} 結語 Utterances 是一個方便的評論系統，可用於 Hugo 靜態網站，它與 GitHub 整合，並通過 Issues 存儲評論，使評論管理變得簡單而有效。添加 Utterances 評論系統可以提升您的網站的互動性和參與度。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/10/hugo-comments/","tags":["Hugo","Git"],"title":" Hugo 添加評論功能"},{"categories":["Tech"],"contents":"前言 之前用的 Jekyll 主題創作者沒在維護，現在版本的 GitHub 不能 build 了，轉移至 Hugo 架設個人網站\n為什麼選擇 Hugo？ Hugo 是一個以 Go 語言編寫的快速靜態網站生成器，它提供了許多優點，包括：\n速度快： Hugo 生成靜態網站的速度極快，這意味著網站的頁面將在訪問者瀏覽時迅速加載。\n主題和佈局： Hugo 具有豐富的主題和佈局選擇，使你能夠輕鬆自定義你的網站外觀。\n活躍的社群： Hugo 有一個活躍的社群，提供了大量的支持和資源，幫助你解決問題。\n易於安裝和部署： Hugo 的安裝和部署過程非常簡單，無論你是使用本地主機還是部署到網路主機，都能輕鬆完成。\n如何在 Mac 上使用 Hugo 運行個人網站？ 步驟 1：安裝 Hugo 安裝 Homebrew\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; 安裝 Hugo\nbrew install hugo 確認 Hugo 安裝成功，並且有出現版本訊息\nhugo --version 因為 macOS 14 的預覽版 (pre-release version)， Homebrew 不支援，所以在安裝 Hugo 和 Git 遇到一些問題。\n可以用以下指令安裝\nbrew install --build-from-source git brew install --build-from-source hugo 步驟 2：匯入主題 這邊我是使用 liva-hugo 主題。\n這裡示範下載 git 上面 zip，下載解壓縮後，裡面有一個資料夾叫exampleSite，把他拉出來放置桌面或其他想存放的路徑。\n然後在exampleSite底下建立一個資料夾命名為themes(注意! 一定要是這個名稱 )， 然後再把解壓縮後的liva-hugo-master，改名為liva-hugo，將這個資料夾放置themes底下。\n步驟 3：啟動 Local Server 打開終端機，進去exampleSite，並啟動 server，將網址放入網頁瀏覽器中，即可以看到畫面。\nhugo server 步驟 4：設置網站配置 可以從根目錄下的config.toml文件中設置網站配置文件，包括站點標題、作者資訊、主題選擇和其他自定義設置。\n介紹其中幾個配置\nbaseURL = https://github帳號.github.io\ntitle = 網站標題配置\nlanguageCode = 網站語系配置\n[menu] = 導航配置\n[params] = 默認參數配置\n[params.search] = 搜索功能配置\n[params.cookies] = Cookie 的啟用及有效時間配置\n[params.social] = 社交媒體配置\n步驟 5：建立 GitHub Page Repository 首先到你的 GitHub 主頁，並且在右上角找到「+」，點選「New Repository」，\nRepository Name 填寫「使用者名稱.github.io」。\n步驟 6：發布至 GitHub Pages 上 編輯好後，在終端機輸入hugo，打包完成將創建一個public目錄`，\n將public裡面所有資料夾和檔案複製到 Clone 下來的使用者名稱.github.io資料夾，推上 GitHub 即可完成部署。\ngit add . \u0026amp;\u0026amp; git commit -m \u0026#34;first commit\u0026#34; \u0026amp;\u0026amp; git push 結語 遷移個人網站從 Jekyll 到 Hugo 可能需要一些工作，但它將確保你的網站保持現代化，並且更易於維護。Hugo 是一個功能豐富且強大的工具，能夠幫助你建立一個引人注目的網站，並提供快速且優質的用戶體驗。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/10/jekyll-to-hugo/","tags":["Hugo","Git"],"title":"使用 Hugo 在 GitHub 上架設個人網站"}]