[{"categories":["Notes"],"contents":"前言 因為工作需要使用到 Zustand，這邊稍微研究一下並實作 Todo List。\nZustand 現在 react 的相關套件裡面最使用最廣泛的全域管理工具應該是 Redux，在工作上較大的專案也都是使用 Redux 在做狀態管理，但是我想要介紹另外一個比較輕量狀態管理工具，Zustand。\nnpm install zustand\n概念 create: 是 Zustand 提供的一個函數，用於創建狀態容器。它接受一個參數，這個參數是一個稱為 State Creator 的函數。在這個函數中，可以定義初始狀態以及一些操作這個狀態的方法。 set: 是一個在 State Creator 函數中可以使用的函數。它允許更新狀態容器的數據。更新函數接受一個參數，這個參數是當前的狀態數據，並且返回新的狀態數據。 總之，create函數用於創建狀態容器，而set函數用於更新狀態。\n程式碼範例 這段程式碼是使用 TypeScript 和 Zustand 庫來建立一個簡單的待辦事項應用程序的狀態管理系統。\n程式碼結構：\nInterface 定義：\nTodo，定義資料結構，包括 ID、內容、完成狀態和編輯狀態等。 TodoState，定義狀態結構，包括一個待辦事項數組和一些操作這些待辦事項的方法。 Todo List 操作函數：\n用於執行各種待辦事項的操作，包括新增、標記完成、刪除和編輯待辦事項等。 useTodo 狀態創建函數：\n創建並返回一個包含狀態和操作函數的對象。這些操作函數內部調用了 Zustand 提供的 set 函數，來更新應用程序的狀態。 create 導出默認值：\n最後，將使用 create 函數導出一個具有預設狀態的狀態儲存容器。 StateCreator\u0026lt;TodoState\u0026gt;：這裡定義了狀態創建函數（State Creator）的類型。它告訴 TypeScript 狀態創建函數的參數類型以及返回的狀態的類型。在這個例子中，TodoState 定義了狀態的結構和方法，所以我們將其傳遞給 StateCreator 來確保狀態創建函數返回的狀態與 TodoState 相符。\ndevtools((set: SetState\u0026lt;TodoState\u0026gt;) =\u0026gt; ({：這裡使用了 devtools 中間件來對狀態進行調試和監控。devtools 函數接受一個函數作為參數，這個函數內部定義了狀態的創建邏輯。在這個函數中，我們明確地指定了 set 函數的類型為 SetState，這樣做是為了確保 set 函數可以正確地更新 TodoState 類型的狀態。\n// state/useTodo.tsx import { create, State, StateCreator, SetState } from \u0026#34;zustand\u0026#34;; import { devtools } from \u0026#34;zustand/middleware\u0026#34;; import { v4 as uuidv4 } from \u0026#34;uuid\u0026#34;; export interface Todo { id: string; todoContent: string; complete: boolean; edit: boolean; } interface TodoState extends State { todos: Array\u0026lt;Todo\u0026gt;; addNewTodo: (todoContent: string) =\u0026gt; void; toggleCompleteTodo: (todoId: string) =\u0026gt; void; deleteTodo: (todoId: string) =\u0026gt; void; toggleEditTodo: (todoId: string) =\u0026gt; void; updateEditingTodoContent: (todoId: string, todoContent: string) =\u0026gt; void; } const todoObj = (todoContent: string): Todo =\u0026gt; { return { id: uuidv4(), todoContent, complete: false, edit: false, }; }; const addNewTodo = (todos: Array\u0026lt;Todo\u0026gt;, todoContent: string): Array\u0026lt;Todo\u0026gt; =\u0026gt; { const todo = todoObj(todoContent); const newTodo = todos.concat(todo); return newTodo; }; const toggleCompleteTodo = (todos: Array\u0026lt;Todo\u0026gt;, todoId: string): Array\u0026lt;Todo\u0026gt; =\u0026gt; { const newTodo = todos.map((todo) =\u0026gt; todo.id === todoId ? { ...todo, complete: !todo.complete } : todo ); return newTodo; }; const deleteTodo = (todos: Array\u0026lt;Todo\u0026gt;, todoId: string): Array\u0026lt;Todo\u0026gt; =\u0026gt; { const newTodo = todos.filter((todo) =\u0026gt; todo.id !== todoId); return newTodo; }; const toggleEditTodo = (todos: Array\u0026lt;Todo\u0026gt;, todoId: string): Array\u0026lt;Todo\u0026gt; =\u0026gt; { const newTodo = todos.map((todo) =\u0026gt; todo.id === todoId ? { ...todo, edit: !todo.edit } : todo ); return newTodo; }; const updateEditingTodoContent = ( todos: Array\u0026lt;Todo\u0026gt;, todoId: string, todoContent: string ): Array\u0026lt;Todo\u0026gt; =\u0026gt; { const newTodo = todos.map((todo) =\u0026gt; todo.id === todoId ? { ...todo, todoContent } : todo ); return newTodo; }; const useTodo: StateCreator\u0026lt;TodoState\u0026gt; = devtools((set: SetState\u0026lt;TodoState\u0026gt;) =\u0026gt; ({ todos: [], addNewTodo: (todoContent: string) =\u0026gt; { set((state: TodoState) =\u0026gt; ({ // 明確指定 state 參數的型別為 TodoState ...state, todos: addNewTodo(state.todos, todoContent), })); }, toggleCompleteTodo: (todoId: string) =\u0026gt; { set((state: TodoState) =\u0026gt; ({ ...state, todos: toggleCompleteTodo(state.todos, todoId), })); }, deleteTodo: (todoId: string) =\u0026gt; { set((state: TodoState) =\u0026gt; ({ ...state, todos: deleteTodo(state.todos, todoId), })); }, toggleEditTodo: (todoId: string) =\u0026gt; { set((state: TodoState) =\u0026gt; ({ ...state, todos: toggleEditTodo(state.todos, todoId), })); }, updateEditingTodoContent: (todoId: string, todoContent: string) =\u0026gt; { set((state: TodoState) =\u0026gt; ({ ...state, todos: updateEditingTodoContent(state.todos, todoId, todoContent), })); }, })); export default create\u0026lt;TodoState\u0026gt;(useTodo); 這時候 component 就可以去接收 golbal 狀態，以下舉例 Form Input 及渲染項目和操作 UI。\n// TodoForm.tsx import * as React from \u0026#34;react\u0026#34;; import { useRef, FormEvent } from \u0026#34;react\u0026#34;; import useTodo from \u0026#34;./state/useTodo\u0026#34;; const TodoForm: React.FC = () =\u0026gt; { const { addNewTodo } = useTodo(); const inputRef = useRef\u0026lt;HTMLInputElement\u0026gt;(null); const handleSubmit = (e: FormEvent\u0026lt;HTMLFormElement\u0026gt;) =\u0026gt; { e.preventDefault(); if (!inputRef.current || !inputRef.current.value.trim()) return; const value = inputRef.current.value.trim(); addNewTodo(value); inputRef.current.value = \u0026#34;\u0026#34;; }; return ( \u0026lt;form onSubmit={handleSubmit}\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;Type in Something ...\u0026#34; ref={inputRef} /\u0026gt; \u0026lt;/form\u0026gt; ); }; export default TodoForm; // Todos.tsx import * as React from \u0026#34;react\u0026#34;; import useTodo, { Todo } from \u0026#34;./state/useTodo\u0026#34;; const Todos: React.FC = () =\u0026gt; { const { todos, toggleCompleteTodo, deleteTodo, toggleEditTodo, updateEditingTodoContent, } = useTodo(); console.log(todos); return ( \u0026lt;div\u0026gt; {todos.map((todo: Todo) =\u0026gt; ( \u0026lt;div className=\u0026#34;todo\u0026#34; key={todo.id}\u0026gt; {todo.edit ? ( \u0026lt;div\u0026gt; \u0026lt;input value={todo.todoContent} onChange={(e) =\u0026gt; updateEditingTodoContent(todo.id, e.target.value) } /\u0026gt; \u0026lt;button className=\u0026#34;save\u0026#34; onClick={() =\u0026gt; toggleEditTodo(todo.id)}\u0026gt; Save \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) : ( \u0026lt;div\u0026gt; \u0026lt;span style={{ textDecoration: todo.complete ? \u0026#34;line-through\u0026#34; : undefined, }} \u0026gt; {todo.todoContent} \u0026lt;/span\u0026gt; \u0026lt;button className=\u0026#34;toggle\u0026#34; onClick={() =\u0026gt; toggleCompleteTodo(todo.id)} \u0026gt; Complete \u0026lt;/button\u0026gt; \u0026lt;button className=\u0026#34;edit\u0026#34; onClick={() =\u0026gt; toggleEditTodo(todo.id)}\u0026gt; Edit \u0026lt;/button\u0026gt; \u0026lt;button className=\u0026#34;delete\u0026#34; onClick={() =\u0026gt; deleteTodo(todo.id)}\u0026gt; Delete \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; )} \u0026lt;/div\u0026gt; ))} \u0026lt;/div\u0026gt; ); }; export default Todos; Demo 示範在 Redux Devtools上 監控 Todo List 操作。\nYour browser does not support the video tag. 結語 透過 Zustand 就可以做到把狀態跟元件分開，而且不需要使用 React 的 Context 或 Provider component 是還蠻方便的。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2024/react-zustand-todos/","tags":["React.js","TypeScript","Zustand"],"title":"使用 Zustand 實作 Todo List"},{"categories":["Notes"],"contents":"前言 以下是我針對 throttle \u0026amp; debounce 兩種方法在React上實作。\nThrottle (節流) 以下範例用throttle實現Infinite Scroll效果。\nDemo 影片中可以看到當滾動頁面到90%位置，就會載入新的元素進來。\nYour browser does not support the video tag. 程式碼範例 這段程式碼使用了閉包（closure）的概念，主要是為了維護 timer 變數的狀態。閉包是指函數內部可以訪問其外部作用域的變數，即使在外部函數已經執行完畢的情況下。\n在這裡，throttle 函數返回了一個匿名函數，而這個匿名函數引用了 timer 變數，形成了閉包。這樣可以確保 timer 的狀態在多次呼叫 throttle 函數時保持一致。\n具體來說：\ntimer 的保存：\n在 throttle 函數內，timer 是一個在外部作用域（throttle 函數）中定義的變數。每次呼叫 throttle 函數，都會創建一個新的 timer 變數，但由於閉包的存在，每個返回的匿名函數都保留對自己的 timer 的引用。 檢查 timer：\n在返回的匿名函數內部，首先檢查 timer 是否存在。如果存在，表示上一次的執行還在範圍內，則直接返回，不執行後續的操作。 執行 setTimeout：\n如果 timer 不存在，則使用 setTimeout 設置一個計時器。這個計時器在指定的時間後會執行提供的 callback 函數。同時，將 timer 設為 null，表示現在已經可以再次觸發。 這種方式保證了在一個特定時間內，只有第一次呼叫 throttle 函數的 callback 函數被執行，後續的呼叫都被忽略。這在一些需要限制執行頻率的情境下是非常有用的。閉包確保了 timer 的狀態在整個過程中的一致性。\n// helper/throttle.js export const throttle = (callback, time) =\u0026gt; { let timer; return () =\u0026gt; { // 如果 timer 存在（表示上一次的執行還在範圍內），則直接返回，不執行後續的操作。 if (timer) { return; } // 如果 timer 不存在，則使用 setTimeout 設置一個計時器， // 當計時器過期時，執行 callback 函數，然後將 timer 設為 null，表示現在已經可以再次觸發。 timer = setTimeout(() =\u0026gt; { callback(); timer = null; }, time); }; }; 這段程式碼實現一個無窮捲動效果，值得注意的是組件掛載時添加了滾動事件監聽器，而在組件卸載時清理這個監聽器，以防止內存洩漏和不必要的事件處理。\n// components/InfiniteScrollDemo/InfiniteScroll.js import React, { useState, useEffect } from \u0026#34;react\u0026#34;; import { throttle } from \u0026#34;../../helper/throttle\u0026#34;; const InfiniteScroll = () =\u0026gt; { // 初始化 paragraphs 的初始資料 const initialParagraphs = Array.from({ length: 30 }, (_, index) =\u0026gt; ( \u0026lt;p key={`origin-${index}`}\u0026gt;123\u0026lt;/p\u0026gt; )); const [paragraphs, setParagraphs] = useState(initialParagraphs); const handleScrollThrottled = throttle(() =\u0026gt; { // 檢查是否滾動到頁面底部 let clientHeight = document.documentElement.clientHeight; let scrollTop = document.documentElement.scrollTop; let scrollHeight = document.documentElement.scrollHeight; if ((scrollTop + clientHeight) / scrollHeight \u0026gt;= 0.9) { // 生成 \u0026#34;456\u0026#34; 字串的 p 標籤節點 const newParagraphs = Array.from({ length: 9 }, (_, index) =\u0026gt; ( \u0026lt;p key={`new-${index + paragraphs.length}`}\u0026gt;456\u0026lt;/p\u0026gt; )); // 更新 paragraphs 狀態 setParagraphs((prevParagraphs) =\u0026gt; [...prevParagraphs, ...newParagraphs]); } }, 1000); useEffect(() =\u0026gt; { // 將 handleScrollThrottled 函數添加到 scroll 事件監聽器 window.addEventListener(\u0026#34;scroll\u0026#34;, handleScrollThrottled); // 在組件卸載時清理滾動事件監聽器 return () =\u0026gt; { window.removeEventListener(\u0026#34;scroll\u0026#34;, handleScrollThrottled); }; }, [handleScrollThrottled]); return \u0026lt;div\u0026gt;{paragraphs}\u0026lt;/div\u0026gt;; }; export default InfiniteScroll; Debounce (防抖) 以下範例用debounce實現延遲對輸入值的處理。\nDemo1 影片中可以確保只有在使用者輸入停頓 1.5 秒後才會觸發對輸入值的處理 (可參照右邊log)。\nYour browser does not support the video tag. 程式碼範例 這段程式碼使用自訂的 useDebounce hook，透過 debounce 技術來降低對輸入值的處理頻率。\n// helper/debounce.js import { useEffect } from \u0026#39;react\u0026#39; // useEffect with debounce const useDebounce = (fn, delay, deps = []) =\u0026gt; { useEffect( () =\u0026gt; { // 設置一個定時器，延遲 delay 毫秒後執行 const timer = setTimeout(fn, delay) // 在每次 useEffect 執行前，清除之前的定時器，確保防彈跳邏輯的正確性 return () =\u0026gt; clearTimeout(timer) }, // eslint-disable-next-line deps ) } export default useDebounce // components/SearchBarDemo/SearchBar.js import React, { useState } from \u0026#34;react\u0026#34;; import useDebounce from \u0026#34;../../helper/debounce\u0026#34;; const SearchBar = () =\u0026gt; { const [inputValue, setInputValue] = useState(\u0026#34;\u0026#34;); const [debouncedValue, setDebouncedValue] = useState(\u0026#34;\u0026#34;); const handleInputChange = (value) =\u0026gt; { setInputValue(value); console.log(\u0026#34;Input Value:\u0026#34;, value); }; useDebounce( () =\u0026gt; { console.log(\u0026#34;Debounced Input Value:\u0026#34;, inputValue); setDebouncedValue(inputValue); }, 1500, [inputValue] ); return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={inputValue} onChange={(e) =\u0026gt; handleInputChange(e.target.value)} placeholder=\u0026#34;Type something...\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;Input Value: {inputValue}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Debounced Value: {debouncedValue}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); }; export default SearchBar; Demo2 影片中用戶實際輸入後停頓後 1.5 秒後，才會觸發 API 請求。\nYour browser does not support the video tag. 程式碼範例 在這邊我是拿到全部資料過濾userId === 1，印出每筆的 title。\n// helper/debounce.js import { useEffect } from \u0026#34;react\u0026#34;; // useEffect with debounce const useDebounce = (fn, delay, deps = []) =\u0026gt; { useEffect( () =\u0026gt; { if (deps.length \u0026gt; 0) { // 設置一個定時器，延遲 delay 毫秒後執行 const timer = setTimeout(fn, delay); // 在每次 useEffect 執行前，清除之前的定時器，確保防彈跳邏輯的正確性 return () =\u0026gt; clearTimeout(timer); } }, // eslint-disable-next-line deps ); }; export default useDebounce; // components/SearchBarDemo/SearchBarAPI.js import React, { useState } from \u0026#34;react\u0026#34;; import useDebounce from \u0026#34;../../helper/debounce\u0026#34;; const SearchBarAPI = () =\u0026gt; { const [inputValue, setInputValue] = useState(\u0026#34;\u0026#34;); const [filteredPosts, setFilteredPosts] = useState([]); const fetchData = async () =\u0026gt; { try { const response = await fetch( `https://jsonplaceholder.typicode.com/posts` ); const data = await response.json(); const filteredData = data.filter((post) =\u0026gt; post.userId === 1); console.log(filteredData); setFilteredPosts(filteredData); } catch (error) { console.error(\u0026#34;Error fetching data:\u0026#34;, error); } }; // 使用 useDebounce 包裹 fetchData，只有在有輸入值的情況下才會觸發資料請求 useDebounce( () =\u0026gt; { if (inputValue) { fetchData(); } }, 1500, [inputValue] ); const handleChange = (event) =\u0026gt; { setInputValue(event.target.value); }; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={inputValue} onChange={handleChange} placeholder=\u0026#34;Type something...\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;Filtered Posts:\u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; {filteredPosts.map((post) =\u0026gt; ( \u0026lt;li key={post.id}\u0026gt;{post.title}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); }; export default SearchBarAPI; 結語 Throttle（節流） 和 Debounce（防抖）是用於控制某些操作執行頻率的兩種不同的技術。這兩種技術主要應用在處理用戶輸入、監聽事件或執行一些高頻率操作的情境中。以下是它們的主要區別：\nThrottle（節流）：\n定義： 當一個操作在固定的時間間隔內只執行一次，不論這段時間內有多少次觸發事件，都只會執行一次。 使用場景： 當你希望限制某個操作的執行頻率，特別是在高頻率事件觸發的情況下，例如滾動事件或鍵盤輸入。 Debounce（防抖）：\n定義： 當一個操作在最後一次觸發事件後，等待一段時間，只有在這段時間內沒有新的觸發事件發生時，才執行該操作。 使用場景： 當你希望等待一段時間，確保用戶已經停止輸入或停止觸發事件，然後再執行相應的操作。這對於節省資源和減少不必要的操作很有用，例如在搜索欄輸入時實時搜索。 簡單來說，節流主要用於控制一個操作的執行頻率，確保在一段時間內只執行一次；而防抖則確保在最後一次觸發事件後的等待時間內沒有新的觸發事件，才執行相應的操作。這兩種技術都有助於提高性能和優化用戶體驗，特別是在處理大量事件或高頻率觸發的情況下。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/11/throttle-debounce-difference/","tags":["React.js"],"title":"前端優化- Throttle \u0026 Debounce"},{"categories":["Portfolio"],"contents":"前言 當時在前公司訂便當的時候，都要跑去每個人座位詢問，挺麻煩的!\n於是決定與一位後端同仁一起搭建午餐機器人。\n架構 這邊我是用 Feathers + MongoDB Atlas 部署到 Render 作品\n後台介面：Feathers、React 和 Feathers Socket.IO 創建一個實時應用程序，並實現數據的即時更新。 LineBot：設定 Channel ID、Channel Secret\u0026hellip;等必要資訊，並 Webhook 路由及處理 LineBot 事件 測試環境用 Ngrok 建立一個 LineBot Webhook 的 HTTPS URL 步驟 1：在 Ngrok官網 創建一個帳戶 步驟 2：執行 Ngrok 下載並解壓縮後你會獲得一個 ngrok 的執行檔。\nMac 環境變數設定：需要將 ngrok 執行檔拖曳到 /usr/local/bin/ 資料夾內。\n切換到/bin目錄 將 Webhook 轉發到本地端口（例如 3030）。\n啟動服務 可以看到 Forwarding 有一個 https 服務，到時候就可以貼到 LineBot Webhook。\nLineBot設定就不再探討，可以去我寫的 LineBot 關鍵字儲存查詢 文章看\n午餐機器人及後台管理 Demo 可在後台新建菜單 這時候可以看見LineBot輸入吃(這邊是我們自己下的指令)，就會產生訂單 接著按下開始訂單，就依照機器人回覆輸入相對應文字 後台介面就可以看到在 LineBot 輸入的資訊了 也可以對成員新增、編輯、刪除、查詢 當同事過來給當天值日生繳錢時，就可以按下付錢，後台頁面也會統計誰沒繳方便查詢 結語 以上就是我們替同事製作的午餐 Bot，大家只要加官方帳號，動手輸入一些指令就能輕鬆訂便當，真的方便許多🎉\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/11/portfolio-lunch-linebot/","tags":["LineBot","Line","Ngrok","React.js","Feathers"],"title":"午餐機器人"},{"categories":["Notes"],"contents":"前言 Lodash 是一個 JavaScript library，提供了很多常用的函式，處理資料可以省去很多時間，有時候也會比原生 JS 的效能還要好。\n安裝 透過 npm\nnpm i --save lodash 使用 import _ from \u0026#39;lodash\u0026#39; 筆記紀錄 介紹幾個比較常用方法 參考 Document\n陣列 1. _.chunk(array, [size=1]) 參數\narray (Array) : 需要處理的陣列 [size=1] (number) : 每個數組區塊的長度 返回\n(Array) : 傳回分割區塊的新陣列 範例\n_.chunk([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;], 2); // =\u0026gt; [[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;], [\u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;]] 2. _.compact(array) 參數\narray (Array) : 需要處理的陣列 返回\n(Array) : 傳回過濾掉「假值」的新陣列(false、null、0、\u0026quot;\u0026quot;、undefined和NaN都是被認為是「假值」。) 範例\n_.compact([0, 1, false, 2, \u0026#39;\u0026#39;, 3]); // =\u0026gt; [1, 2, 3] 3. _.concat(array, [values]) 參數\narray (Array) : 被連接的陣列 [values] (\u0026hellip;*) : 連接的值 返回\n(Array) : 回傳數組連接後新陣列 範例\n// 合併多個數組 const array1 = [1, 2]; const array2 = [3, 4]; const array3 = [5, 6]; const result = _.concat(array1, array2, array3); console.log(result); // =\u0026gt; [1, 2, 3, 4, 5, 6] // 合併數組和其他值 const array = [1, 2]; const other = _.concat(array, 3, [4], 5); console.log(other); // =\u0026gt; [1, 2, 3, 4, 5] // 合併多維數組 const array1 = [1, [2, 3]]; const array2 = [4, [5, 6]]; const result = _.concat(array1, array2); console.log(result); // =\u0026gt; [1, [2, 3], 4, [5, 6]] // 合併空數組 const array = [1]; const emptyArray = []; const result = _.concat(array, emptyArray); console.log(result); // =\u0026gt; [1] 4. _.difference(array, [values]) 參數\narray (Array) : 要檢查的陣列 [values] (\u0026hellip;Array) : 排除的值 返回\n(Array) : 傳回一個計算數組之間差異後的新陣列 範例\n_.difference([3, 2, 1], [4, 2]); // =\u0026gt; [3, 1] 5. .differenceBy(array, [values], [iteratee=.identity]) 參數\narray (Array) : 要檢查的陣列 [values] (\u0026hellip;Array) : 排除的值 [iteratee=_.identity] (Array|Function|Object|string) : iteratee 呼叫每個元素 返回\n(Array) : 傳回一個計算數組之間差異後的新陣列 範例\nconst array1 = [{ \u0026#39;x\u0026#39;: 1 }, { \u0026#39;x\u0026#39;: 2 }, { \u0026#39;x\u0026#39;: 3 }]; const array2 = [{ \u0026#39;x\u0026#39;: 3 }, { \u0026#39;x\u0026#39;: 4 }, { \u0026#39;x\u0026#39;: 5 }]; // 使用 \u0026#39;x\u0026#39; 屬性來屬性來確定對象唯一性 const difference = _.differenceBy(array1, array2, \u0026#39;x\u0026#39;); console.log(difference); // =\u0026gt; [{ \u0026#39;x\u0026#39;: 1 }, { \u0026#39;x\u0026#39;: 2 }] 6. .findIndex(array, [predicate=.identity], [fromIndex=0]) 參數\narray (Array) : 要搜尋的陣列 [predicate=_.identity] (Array|Function|Object|string) : 這個函數會在每一次迭代呼叫 [fromIndex=0] (number) : The index to search from 返回\n(number) : 傳回找到元素的索引值（index），否則傳回-1 範例\n// 找大於30歲索引 const users = [ { name: \u0026#39;Alice\u0026#39;, age: 25 }, { name: \u0026#39;Bob\u0026#39;, age: 30 }, { name: \u0026#39;Charlie\u0026#39;, age: 35 }, { name: \u0026#39;David\u0026#39;, age: 40 } ]; const index = _.findIndex(users, (user) =\u0026gt; user.age \u0026gt; 30); console.log(index); // =\u0026gt; 2 // 從索引1找大於30歲索引 const users = [ { name: \u0026#39;Alice\u0026#39;, age: 25 }, { name: \u0026#39;Bob\u0026#39;, age: 30 }, { name: \u0026#39;Charlie\u0026#39;, age: 35 }, { name: \u0026#39;David\u0026#39;, age: 40 } ]; const index = _.findIndex(users, (user) =\u0026gt; user.age \u0026gt; 30, 1); console.log(index); // =\u0026gt; 2 7. .findLastIndex(array, [predicate=.identity], [fromIndex=array.length-1]) 參數\narray (Array) : 要搜尋的陣列 [predicate=_.identity] (Array|Function|Object|string) : 這個函數會在每一次迭代呼叫 [fromIndex=array.length-1] (number) : The index to search from 返回\n(number) : 傳回找到元素的索引值（index），否則傳回-1 範例\n// 找等於30歲最後一筆索引 const users = [ { name: \u0026#39;Alice\u0026#39;, age: 25 }, { name: \u0026#39;Bob\u0026#39;, age: 30 }, { name: \u0026#39;Charlie\u0026#39;, age: 35 }, { name: \u0026#39;David\u0026#39;, age: 30 } ]; const index = _.findLastIndex(users, (user) =\u0026gt; user.age === 30); console.log(index); // =\u0026gt; 3 // 從索引1找等於30歲最後一筆索引 const users = [ { name: \u0026#39;Alice\u0026#39;, age: 25 }, { name: \u0026#39;Bob\u0026#39;, age: 30 }, { name: \u0026#39;Charlie\u0026#39;, age: 35 }, { name: \u0026#39;David\u0026#39;, age: 30 } ]; const index = _.findLastIndex(users, (user) =\u0026gt; user.age === 30, 1); console.log(index); // =\u0026gt; 3 8. _.head(array) 參數\narray (Array) : 要查詢的陣列 返回\n(*) : 傳回陣列 array 的第一個元素 範例\n_.head([1, 2, 3]); // =\u0026gt; 1 _.head([]); // =\u0026gt; undefined 9. _.flatten(array) 參數\narray (Array) : 需要減少巢狀層級的陣列 返回\n(Array) : 傳回減少巢狀層級後的新陣列 範例\nconst nestedArray = [1, [2, [3, [4]], 5]]; const flatArray = _.flatten(nestedArray); console.log(flatArray); // =\u0026gt; [1, 2, [3, [4]], 5] 10. _.flattenDeep(array) 參數\narray (Array) : 需要處理的陣列 返回\n(Array) : 傳回一個的新一維數組 範例\nconst deeplyNestedArray = [1, [2, [3, [4]], 5]]; const fullyFlatArray = _.flattenDeep(deeplyNestedArray); console.log(fullyFlatArray); // =\u0026gt; [1, 2, 3, 4, 5] 11. _.intersection([arrays]) 參數\n[arrays] (\u0026hellip;Array) : 待檢查的陣列 返回\n(Array) : 傳回一個包含所有傳入陣列交集元素的新陣列 範例\n_.intersection([2, 1], [4, 2], [1, 2]); // =\u0026gt; [2] 12. _.join(array, [separator=\u0026rsquo;,\u0026rsquo;]) 參數\narray (Array) : 要轉換的陣列 [separator=\u0026rsquo;,\u0026rsquo;] (string) : 分隔元素 返回\n(string) : 傳回連接字串 範例\n_.join([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;], \u0026#39;~\u0026#39;); // =\u0026gt; \u0026#39;a~b~c\u0026#39; 13. _.last(array) 參數\narray (Array) : 要檢索的陣列 返回\n(*) : 返回 array 中的最後一個元素 範例\n_.last([1, 2, 3]); // =\u0026gt; 3 14. _.pull(array, [values]) 參數\narray (Array) : 要修改的陣列 [values] (\u0026hellip;*) : 要刪除的值 返回\n(Array) : 返回 array 範例\nconst array = [1, 2, 3, 1, 2, 3]; _.pull(array, 2, 3); console.log(array); // =\u0026gt; [1, 1] 15. .pullAllBy(array, values, [iteratee=.identity]) 參數\narray (Array) : 要修改的陣列 values (Array) : 要移除值的陣列 [iteratee=_.identity] (Array|Function|Object|string) : iteratee（迭代器）呼叫每個元素 返回\n(Array) : 返回 array 範例\nconst array = [{ \u0026#39;x\u0026#39;: 1 }, { \u0026#39;x\u0026#39;: 2 }, { \u0026#39;x\u0026#39;: 3 }, { \u0026#39;x\u0026#39;: 1 }]; _.pullAllBy(array, [{ \u0026#39;x\u0026#39;: 1 }, { \u0026#39;x\u0026#39;: 3 }], \u0026#39;x\u0026#39;); console.log(array); // =\u0026gt; [{ \u0026#39;x\u0026#39;: 2 }] 16. .remove(array, [predicate=.identity]) 參數\narray (Array) : 要修改的陣列 [predicate=_.identity] (Array|Function|Object|string) : 每次迭代呼叫的函數 返回\n(Array) : 傳回移除元素組成的新陣列 範例\nconst array = [1, 2, 3, 4]; const evens = _.remove(array, function(n) { return n % 2 == 0; }); console.log(array); // =\u0026gt; [1, 3] console.log(evens); // =\u0026gt; [2, 4] 17. _.slice(array, [start=0], [end=array.length]) 參數\narray (Array) : 要裁剪數組 [start=0] (number) : 開始位置 [end=array.length] (number) : 結束位置 返回\n(Array) : 傳回陣列 array 裁剪部分的新陣列 範例\nconst array = [1, 2, 3, 4, 5]; // 從索引 1 到索引 3 之間 （不包括索引 3） const slicedArray = _.slice(array, 1, 3); console.log(slicedArray); // =\u0026gt; [2, 3] const array = [1, 2, 3, 4, 5]; // 從索引 2 到最後 const slicedArray = _.slice(array, 2); console.log(slicedArray); // =\u0026gt; [3, 4, 5] 18. _.take(array, [n=1]) 參數\narray (Array) : 要檢索的陣列 [n=1] (number) : 要提取的元素個數 返回\n(Array) : 傳回 array 陣列的切片（從起始元素開始 n 個元素） 範例\n_.take([1, 2, 3]); // =\u0026gt; [1] _.take([1, 2, 3], 2); // =\u0026gt; [1, 2] _.take([1, 2, 3], 5); // =\u0026gt; [1, 2, 3] _.take([1, 2, 3], 0); // =\u0026gt; [] 19. _.uniq(array) 參數\narray (Array) : 要檢查的陣列 返回\n(Array) : 傳回新的去重後的陣列 範例\nconst array = [1, 2, 2, 3, 4, 4, 5]; const uniqueArray = _.uniq(array); console.log(uniqueArray); // =\u0026gt; [1, 2, 3, 4, 5] 20. .uniqBy(array, [iteratee=.identity]) 參數\narray (Array) : 要檢查的陣列 [iteratee=_.identity] (Array|Function|Object|string) : 迭代函數，呼叫每個元素 返回\n(Array) : 傳回新的去重後的陣列 範例\nconst objects = [ { id: 1, name: \u0026#39;Alice\u0026#39; }, { id: 2, name: \u0026#39;Bob\u0026#39; }, { id: 1, name: \u0026#39;Charlie\u0026#39; }, { id: 3, name: \u0026#39;David\u0026#39; }, ]; // 基于 \u0026#39;id\u0026#39; 属性來确定元素的唯一性 const uniqueObjects = _.uniqBy(objects, \u0026#39;id\u0026#39;); console.log(uniqueObjects); // =\u0026gt; [ { id: 1, name: \u0026#39;Alice\u0026#39; }, { id: 2, name: \u0026#39;Bob\u0026#39; }, { id: 3, name: \u0026#39;David\u0026#39; } ] 集合 Collection 1. .countBy(collection, [iteratee=.identity]) 參數\ncollection (Array|Object) : 一個用來迭代的集合 [iteratee=_.identity] (Array|Function|Object|string) : 一個迭代函數，用來轉換 key（鍵） 返回\n(Object) : 傳回一個組成集合物件 範例\nconst numbers = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]; // 將元素的值分組，，並計算次數 const countByResult = _.countBy(numbers); console.log(countByResult); // =\u0026gt; { \u0026#39;1\u0026#39;: 1, \u0026#39;2\u0026#39;: 2, \u0026#39;3\u0026#39;: 3, \u0026#39;4\u0026#39;: 4 } 2. .forEach(collection, [iteratee=.identity]) 參數\ncollection (Array|Object) : 一個用來迭代的集合 [iteratee=_.identity] (Function) : 每次迭代呼叫的函數 返回\n(*) : 傳回集合 collection 範例\nconst array = [1, 2, 3, 4, 5]; _.forEach(array, (element) =\u0026gt; { console.log(element); }); const object = { a: 1, b: 2, c: 3 }; _.forEach(object, (value, key) =\u0026gt; { console.log(key, value); }); 3. .every(collection, [predicate=.identity]) 參數\ncollection (Array|Object) : 一個用來迭代的集合 [predicate=_.identity] (Array|Function|Object|string) : 每次迭代呼叫的函數 返回\n(boolean) : 如果所有元素經 predicate（斷言函數） 檢查後都返回真值，那麼就返回 true，否則返回 false 範例\nconst numbers = [1, 2, 3, 4, 5]; // 使用 _.every 檢查陣列中的所有元素是否都大於 0 const allPositive = _.every(numbers, (num) =\u0026gt; num \u0026gt; 0); console.log(allPositive); // =\u0026gt; true const students = { Alice: { grade: 85 }, Bob: { grade: 92 }, Charlie: { grade: 78 }, }; // 使用 _.every 檢查所有學生的成績是否都大於等於 80 const allGoodGrades = _.every(students, (student) =\u0026gt; student.grade \u0026gt;= 80); console.log(allGoodGrades); // =\u0026gt; false 4. .filter(collection, [predicate=.identity]) 參數\ncollection (Array|Object) : 一個用來迭代的集合 [predicate=_.identity] (Array|Function|Object|string) : 每次迭代呼叫的函數 返回\n(Array) : 傳回一個新的過濾後的陣列 範例\nconst numbers = [1, 2, 3, 4, 5]; // 使用 _.filter 篩選陣列中的所有偶數 const evenNumbers = _.filter(numbers, (num) =\u0026gt; num % 2 === 0); console.log(evenNumbers); // =\u0026gt; [2, 4] 5. .find(collection, [predicate=.identity], [fromIndex=0]) 參數\ncollection (Array|Object) : 一個用來迭代的集合 [predicate=_.identity] (Array|Function|Object|string) : 每次迭代呼叫的函數 [fromIndex=0] (number) : 開始搜尋的索引位置 返回\n(*) : 傳回符合元素，否則回傳 undefined 範例\nconst numbers = [1, 2, 3, 4, 5]; // 使用 _.find 找數組第一個偶數 const firstEvenNumber = _.find(numbers, (num) =\u0026gt; num % 2 === 0); console.log(firstEvenNumber); // =\u0026gt; 2 6. .flatMap(collection, [iteratee=.identity]) 參數\ncollection (Array|Object) : 一個用來迭代遍歷的集合 [iteratee=_.identity] (Array|Function|Object|string) : 每次迭代呼叫的函數 返回\n(Array) : 傳回新扁平化陣列 範例\nfunction duplicate(n) { return [n, n]; } _.flatMap([1, 2], duplicate); // =\u0026gt; [1, 1, 2, 2] 7. .groupBy(collection, [iteratee=.identity]) 參數\ncollection (Array|Object) : 一個用來迭代的集合 [iteratee=_.identity] (Array|Function|Object|string) : 這個迭代函數用來轉換 key 返回\n(Object) : 傳回一個組成聚合的物件 範例\nconst numbers = [1, 2, 3, 4, 5, 6]; // 使用 _.groupBy 根據元素的奇偶性分組 const groupedNumbers = _.groupBy(numbers, (num) =\u0026gt; (num % 2 === 0) ? \u0026#39;偶數\u0026#39; : \u0026#39;奇數\u0026#39;); console.log(groupedNumbers); /* 輸出: { \u0026#39;奇數\u0026#39;: [1, 3, 5], \u0026#39;偶數\u0026#39;: [2, 4, 6] } */ const students = { Alice: { grade: \u0026#39;A\u0026#39; }, Bob: { grade: \u0026#39;B\u0026#39; }, Charlie: { grade: \u0026#39;A\u0026#39; }, David: { grade: \u0026#39;C\u0026#39; }, }; // 使用 _.groupBy 根據學生成績分組 const groupedStudents = _.groupBy(students, (student) =\u0026gt; student.grade); console.log(groupedStudents); /* 輸出: { \u0026#39;A\u0026#39;: [ { grade: \u0026#39;A\u0026#39; }, { grade: \u0026#39;A\u0026#39; } ], \u0026#39;B\u0026#39;: [ { grade: \u0026#39;B\u0026#39; } ], \u0026#39;C\u0026#39;: [ { grade: \u0026#39;C\u0026#39; } ] } */ 8. _.includes(collection, value, [fromIndex=0]) 參數\ncollection (Array|Object|string) : 要檢索的集合 value (*) : 要檢索的值 [fromIndex=0] (number) : 要檢索的索引位置 返回\n(boolean) : 如果找到 value 返回 true， 否則返回 false 範例\n_.includes([1, 2, 3], 1); // =\u0026gt; true _.includes([1, 2, 3], 1, 2); // =\u0026gt; false _.includes({ \u0026#39;user\u0026#39;: \u0026#39;fred\u0026#39;, \u0026#39;age\u0026#39;: 40 }, \u0026#39;fred\u0026#39;); // =\u0026gt; true _.includes(\u0026#39;pebbles\u0026#39;, \u0026#39;eb\u0026#39;); // =\u0026gt; true 9. .keyBy(collection, [iteratee=.identity]) 參數\ncollection (Array|Object) : 用來迭代的集合 [iteratee=_.identity] (Array|Function|Object|string) : 這個迭代函數用來轉換 key 返回\n(Object) : 傳回一個組成聚合的物件 範例\nconst students = { { id: 1, name: \u0026#39;Alice\u0026#39;, grade: \u0026#39;A\u0026#39; }, { id: 2, name: \u0026#39;Bob\u0026#39;, grade: \u0026#39;B\u0026#39; }, { id: 3, name: \u0026#39;Charlie\u0026#39;, grade: \u0026#39;A\u0026#39; }, { id: 4, name: \u0026#39;David\u0026#39;, grade: \u0026#39;C\u0026#39; }, }; // 使用 _.keyBy 根據學生的 id 屬性創建物件 const studentsById = _.keyBy(students, \u0026#39;id\u0026#39;); console.log(studentsById); /* 輸出: { \u0026#39;1\u0026#39;: { id: 1, name: \u0026#39;Alice\u0026#39;, grade: \u0026#39;A\u0026#39; }, \u0026#39;2\u0026#39;: { id: 2, name: \u0026#39;Bob\u0026#39;, grade: \u0026#39;B\u0026#39; }, \u0026#39;3\u0026#39;: { id: 3, name: \u0026#39;Charlie\u0026#39;, grade: \u0026#39;A\u0026#39; }, \u0026#39;4\u0026#39;: { id: 4, name: \u0026#39;David\u0026#39;, grade: \u0026#39;C\u0026#39; } } */ 10. .map(collection, [iteratee=.identity]) 參數\ncollection (Array|Object) : 用來迭代的集合 [iteratee=_.identity] (Array|Function|Object|string) : 每次迭代呼叫的函數 返回\n(Array) : 傳回新的映射後陣列 範例\nconst numbers = [1, 2, 3, 4, 5]; const doubledNumbers = _.map(numbers, (num) =\u0026gt; num * 2); console.log(doubledNumbers); // =\u0026gt; [2, 4, 6, 8, 10] 11. .orderBy(collection, [iteratees=[.identity]], [orders]) 參數\ncollection (Array|Object) : 用來迭代的集合 [iteratees=[_.identity]] (Array[]|Function[]|Object[]|string[]) : 排序的迭代函數 [orders] (string[]) :iteratees 迭代函數的排序順序 返回\n(Array) : 排序排序後的新陣列 範例\nconst users = [ { \u0026#39;user\u0026#39;: \u0026#39;fred\u0026#39;, \u0026#39;age\u0026#39;: 48 }, { \u0026#39;user\u0026#39;: \u0026#39;barney\u0026#39;, \u0026#39;age\u0026#39;: 34 }, { \u0026#39;user\u0026#39;: \u0026#39;fred\u0026#39;, \u0026#39;age\u0026#39;: 40 }, { \u0026#39;user\u0026#39;: \u0026#39;barney\u0026#39;, \u0026#39;age\u0026#39;: 36 } ]; // 以 `user` 升序排序 再 `age` 以降序排序。 _.orderBy(users, [\u0026#39;user\u0026#39;, \u0026#39;age\u0026#39;], [\u0026#39;asc\u0026#39;, \u0026#39;desc\u0026#39;]); // =\u0026gt; objects for [[\u0026#39;barney\u0026#39;, 36], [\u0026#39;barney\u0026#39;, 34], [\u0026#39;fred\u0026#39;, 48], [\u0026#39;fred\u0026#39;, 40]] 12. .reduce(collection, [iteratee=.identity], [accumulator]) 參數\ncollection (Array|Object) : 用來迭代的集合 [iteratee=_.identity] (Function) : 每次迭代呼叫的函數 [accumulator] (*) : 初始值 返回\n(*) : 傳回累加後的值 範例\n_.reduce([1, 2], function(sum, n) { return sum + n; }, 0); // =\u0026gt; 3 13. _.size(collection) 參數\ncollection (Array|Object) : 要檢查的集合 返回\n(number) : 傳回集合的長度 範例\n_.size([1, 2, 3]); // =\u0026gt; 3 _.size({ \u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2 }); // =\u0026gt; 2 _.size(\u0026#39;pebbles\u0026#39;); // =\u0026gt; 7 14. .some(collection, [predicate=.identity]) 參數\ncollection (Array|Object) : 用來迭代的集合 [predicate=_.identity] (Array|Function|Object|string) : 每次迭代呼叫的函數 返回\n(boolean) : 如果任意元素經 predicate 檢查都為 truthy（真值），返回 true，否則返回 false 範例\n_.some([null, 0, \u0026#39;yes\u0026#39;, false], Boolean); // =\u0026gt; true var users = [ { \u0026#39;user\u0026#39;: \u0026#39;barney\u0026#39;, \u0026#39;active\u0026#39;: true }, { \u0026#39;user\u0026#39;: \u0026#39;fred\u0026#39;, \u0026#39;active\u0026#39;: false } ]; // The `_.matches` iteratee shorthand. _.some(users, { \u0026#39;user\u0026#39;: \u0026#39;barney\u0026#39;, \u0026#39;active\u0026#39;: false }); // =\u0026gt; false // The `_.matchesProperty` iteratee shorthand. _.some(users, [\u0026#39;active\u0026#39;, false]); // =\u0026gt; true // The `_.property` iteratee shorthand. _.some(users, \u0026#39;active\u0026#39;); // =\u0026gt; true 15. .sortBy(collection, [iteratees=[.identity]]) 參數\ncollection (Array|Object) : 用來迭代的集合 [iteratees=[_.identity]] (\u0026hellip;(Array|Array[]|Function|Function[]|Object|Object[]|string|string[])) : 這個函數決定排序 返回\n(Array) : 傳回排序後的陣列 範例\nconst products = [ { name: \u0026#39;Apple\u0026#39;, price: 2.5 }, { name: \u0026#39;Banana\u0026#39;, price: 1.2 }, { name: \u0026#39;Orange\u0026#39;, price: 3.0 }, { name: \u0026#39;Mango\u0026#39;, price: 2.8 }, ]; const sortedProducts = _.sortBy(products, (product) =\u0026gt; product.price); console.log(sortedProducts); /* 輸出: [ { name: \u0026#39;Banana\u0026#39;, price: 1.2 }, { name: \u0026#39;Apple\u0026#39;, price: 2.5 }, { name: \u0026#39;Mango\u0026#39;, price: 2.8 }, { name: \u0026#39;Orange\u0026#39;, price: 3.0 } ] */ 函數 1. _.debounce(func, [wait=0], [options=]) 參數\nfunc (Function) : 要防抖動的函數 [wait=0] (number) : 需要延遲的毫秒數 [options=] (Object) : 選項物件 [options.leading=false] (boolean) : 指定在延遲開始前呼叫 [options.maxWait] (number) : 設定 func 允許被延遲的最大值 [options.trailing=true] (boolean) : 指定在延遲結束後呼叫 返回\n(Function) : 傳回新的 debounced（防抖動）函數 範例\n// 使用 Lodash 的 _.debounce 創建一個延遲執行的函數 const debouncedFunction = _.debounce((text) =\u0026gt; { console.log(`用戶輸入: ${text}`); }, 500); // 模擬用戶輸入 debouncedFunction(\u0026#39;A\u0026#39;); debouncedFunction(\u0026#39;B\u0026#39;); // 500 毫秒後只執行一次回調 // 輸出: 用戶輸入: B 語言 Lang 1. _.clone(value) 參數\nvalue (*) : 要拷貝的值 返回\n(*) : 傳回拷貝後的值 範例\nconst objects = [{ \u0026#39;a\u0026#39;: 1 }, { \u0026#39;b\u0026#39;: 2 }]; const shallow = _.clone(objects); console.log(shallow[0] === objects[0]); // =\u0026gt; true 2. _.cloneDeep(value) 參數\nvalue (*) : 要深拷貝的值 返回\n(*) : 傳回拷貝後的值 範例\nconst objects = [{ \u0026#39;a\u0026#39;: 1 }, { \u0026#39;b\u0026#39;: 2 }]; const deep = _.cloneDeep(objects); console.log(deep[0] === objects[0]); // =\u0026gt; false 3. _.isArray(value) 參數\nvalue (*) : 要檢查的值 返回\n(boolean) : 如果 value 是一個陣列返回 true，否則返回 false 範例\n_.isArray([1, 2, 3]); // =\u0026gt; true _.isArray(\u0026#39;abc\u0026#39;); // =\u0026gt; false 4. _.isBoolean(value) 參數\nvalue (*) : 要檢查的值 返回\n(boolean) : 如果 value 是一個布林值，那麼返回 true，否則返回 false 範例\n_.isBoolean(false); // =\u0026gt; true _.isBoolean(null); // =\u0026gt; false 5. _.isEmpty(value) 參數\nvalue (*) : 要檢查的值 返回\n(boolean) : 如果 value 為空，則返回 true，否則返回 false 範例\n_.isEmpty(null); // =\u0026gt; true _.isEmpty(true); // =\u0026gt; true _.isEmpty(1); // =\u0026gt; true _.isEmpty([1, 2, 3]); // =\u0026gt; false _.isEmpty({ \u0026#39;a\u0026#39;: 1 }); // =\u0026gt; false 6. _.isEqual(value, other) 參數\nvalue (*) : 用來比較的值 other (*) : 另一個用來比較的值 返回\n(boolean) : 如果兩個值完全相同，那麼返回 true，否則返回 false 範例\nconst object = { \u0026#39;a\u0026#39;: 1 }; const other = { \u0026#39;a\u0026#39;: 1 }; _.isEqual(object, other); // =\u0026gt; true object === other; // =\u0026gt; false 7. _.isError(value) 參數\nvalue (*) : 要檢查的值 返回\n(boolean) : 如果 value 是一個錯誤（Error）對象，那麼返回 true，否則返回 false 範例\n_.isError(new Error); // =\u0026gt; true _.isError(Error); // =\u0026gt; false 8. _.isFunction(value) 參數\nvalue (*) : 要檢查的值 返回\n(boolean) : 如果 value 是一個函數，那麼返回 true，否則返回 false 範例\n_.isFunction(_); // =\u0026gt; true _.isFunction(/abc/); // =\u0026gt; false 9. _.isNaN(value) 參數\nvalue (*) : 要檢查的值 返回\n(boolean) : 如果 value 是一個 NaN，那麼返回 true，否則返回 false 範例\n_.isNaN(NaN); // =\u0026gt; true _.isNaN(new Number(NaN)); // =\u0026gt; true isNaN(undefined); // =\u0026gt; true _.isNaN(undefined); // =\u0026gt; false 10. _.isNil(value) 參數\nvalue (*) : 要檢查的值 返回\n(boolean) : 如果 value 為 null 或 undefined，那麼返回 true，否則返回 false 範例\n_.isNil(null); // =\u0026gt; true _.isNil(void 0); // =\u0026gt; true _.isNil(NaN); // =\u0026gt; false 11. _.isNull(value) 參數\nvalue (*) : 要檢查的值 返回\n(boolean) : 如果 value 為 null，那麼返回 true，否則返回 false 範例\n_.isNull(null); // =\u0026gt; true _.isNull(void 0); // =\u0026gt; false 12. _.isNumber(value) 參數\nvalue (*) : 要檢查的值 返回\n(boolean) : 如果 value 為一個數值，則返回 true，否則返回 false 範例\n_.isNumber(3); // =\u0026gt; true _.isNumber(Number.MIN_VALUE); // =\u0026gt; true _.isNumber(Infinity); // =\u0026gt; true _.isNumber(\u0026#39;3\u0026#39;); // =\u0026gt; false 13. _.isObject(value) 參數\nvalue (*) : 要檢查的值 返回\n(boolean) : 如果 value 為一個對象，那麼返回 true，否則返回 false 範例\n_.isObject({}); // =\u0026gt; true _.isObject([1, 2, 3]); // =\u0026gt; true _.isObject(_.noop); // =\u0026gt; true _.isObject(null); // =\u0026gt; false 14. _.isString(value) 參數\nvalue (*) : 要檢查的值 返回\n(boolean) : 如果 value 為一個字串，那麼返回 true，否則返回 false 範例\n_.isString(\u0026#39;abc\u0026#39;); // =\u0026gt; true _.isString(1); // =\u0026gt; false 15. _.isUndefined(value) 參數\nvalue (*) : 要檢查的值 返回\n(boolean) : 如果 value 是 undefined，那麼返回 true，否則返回 false 範例\n_.isUndefined(void 0); // =\u0026gt; true _.isUndefined(null); // =\u0026gt; false 16. _.toArray(value) 參數\nvalue (*) : 要轉換的值 返回\n(Array) : 傳回轉換後的陣列 範例\n_.toArray({ \u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2 }); // =\u0026gt; [1, 2] _.toArray(\u0026#39;abc\u0026#39;); // =\u0026gt; [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] _.toArray(1); // =\u0026gt; [] _.toArray(null); // =\u0026gt; [] 17. _.toNumber(value) 參數\nvalue (*) : 要處理的值 返回\n(number) : 回傳數字 範例\n_.toNumber(3.2); // =\u0026gt; 3.2 _.toNumber(Number.MIN_VALUE); // =\u0026gt; 5e-324 _.toNumber(Infinity); // =\u0026gt; Infinity _.toNumber(\u0026#39;3.2\u0026#39;); // =\u0026gt; 3.2 18. _.toString(value) 參數\nvalue (*) : 要處理的值 返回\n(string) : 傳回字串 範例\n_.toString(null); // =\u0026gt; \u0026#39;\u0026#39; _.toString(-0); // =\u0026gt; \u0026#39;-0\u0026#39; _.toString([1, 2, 3]); // =\u0026gt; \u0026#39;1,2,3\u0026#39; 數學 1. _.floor(number, [precision=0]) 參數\nnumber (number) : 要向下捨入的值 [precision=0] (number) : 向下舍入的精度 返回\n(number) : 傳迴向下舍入的值 範例\n_.floor(4.006); // =\u0026gt; 4 _.floor(0.046, 2); // =\u0026gt; 0.04 _.floor(4060, -2); // =\u0026gt; 4000 2. _.max(array) 參數\narray (Array) : 要迭代的陣列 返回\n(*) : 傳回最大的值 範例\n_.max([4, 2, 8, 6]); // =\u0026gt; 8 _.max([]); // =\u0026gt; undefined 3. _.min(array) 參數\narray (Array) : 要迭代的陣列 返回\n(*) : 傳回最小的值 範例\n_.min([4, 2, 8, 6]); // =\u0026gt; 2 _.min([]); // =\u0026gt; undefined 4. _.round(number, [precision=0]) 參數\nnumber (number) : 要四捨五入的數字 [precision=0] (number) : 四捨五入的精度 返回\n(number) : 傳回四捨五入的數字 範例\n_.round(4.006); // =\u0026gt; 4 _.round(4.006, 2); // =\u0026gt; 4.01 _.round(4060, -2); // =\u0026gt; 4100 5. _.sum(array) 參數\narray (Array) : 要迭代的陣列 返回\n(number) : 傳回總和 範例\n_.sum([4, 2, 8, 6]); // =\u0026gt; 20 數位 1. _.random([lower=0], [upper=1], [floating]) 參數\n[lower=0] (number) : 下限 [upper=1] (number) : 上限 [floating] (boolean) : 指定是否傳回浮點數 返回\n(number) : 傳回隨機數 範例\n_.random(0, 5); // =\u0026gt; an integer between 0 and 5 _.random(5); // =\u0026gt; also an integer between 0 and 5 _.random(5, true); // =\u0026gt; a floating-point number between 0 and 5 _.random(1.2, 5.2); // =\u0026gt; a floating-point number between 1.2 and 5.2 物件 1. _.assign(object, [sources]) 參數\nobject (Object) : 目標物件 [sources] (\u0026hellip;Object) : 來源物件 返回\n(Object) : 返回 object 範例\nconst target = { a: 1, b: 2 }; const source = { b: 3, c: 4 }; // 使用 _.assign 將 source 對象的屬性複製到 target 對象 const mergedObject = _.assign(target, source); console.log(mergedObject); /* 輸出: { a: 1, b: 3, c: 4 } */ 2. _.get(object, path, [defaultValue]) 參數\nobject (Object) : 要檢索的物件 path (Array|string) : 要取得屬性的路徑 [defaultValue] (*) : 如果解析值是 undefined，這值會被回傳 返回\n(*) : 傳回解析的值 範例\nconst object = { \u0026#39;a\u0026#39;: [{ \u0026#39;b\u0026#39;: { \u0026#39;c\u0026#39;: 3 } }] }; _.get(object, \u0026#39;a[0].b.c\u0026#39;); // =\u0026gt; 3 _.get(object, [\u0026#39;a\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); // =\u0026gt; 3 _.get(object, \u0026#39;a.b.c\u0026#39;, \u0026#39;default\u0026#39;); // =\u0026gt; \u0026#39;default\u0026#39; 3. _.has(object, path) 參數\nobject (Object) : 要檢索的物件 path (Array|string) : 要檢查的路徑 path 返回\n(boolean) : 如果 path 存在，那麼返回 true，否則返回 false 範例\nconst object = { a: 1, b: 2, c: 3 }; const hasPropertyB = _.has(object, \u0026#39;b\u0026#39;); console.log(hasPropertyB); // =\u0026gt; true 4. _.keys(object) 參數\nobject (Object) : 要檢索的物件 返回\n(Array) : 傳回包含屬性名的陣列 範例\nconst object = { a: 1, b: 2, c: 3 }; const keys = _.keys(object); console.log(keys); // =\u0026gt; [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] 5. .mapKeys(object, [iteratee=.identity]) 參數\nobject (Object) : 要遍歷的物件 [iteratee=_.identity] (Function) : 每次迭代時呼叫的函數 返回\n(Object) : 傳回映射後的新物件 範例\nconst originalObject = { firstName: \u0026#39;Alice\u0026#39;, lastName: \u0026#39;Johnson\u0026#39; }; const newObject = _.mapKeys(originalObject, (value, key) =\u0026gt; { // 轉換大寫 return key.toUpperCase(); }); console.log(newObject); /* 輸出: { FIRSTNAME: \u0026#39;Alice\u0026#39;, LASTNAME: \u0026#39;Johnson\u0026#39; } */ 6. .mapValues(object, [iteratee=.identity]) 參數\nobject (Object) : 要遍歷的物件 [iteratee=_.identity] (Function) : 每次迭代時呼叫的函數 返回\n(Object) : 傳回映射後的新物件 範例\nconst originalObject = { a: 1, b: 2, c: 3 }; const newObject = _.mapValues(originalObject, (value) =\u0026gt; { return value * 2; }); console.log(newObject); /* 輸出: { a: 2, b: 4, c: 6 } */ 7. _.merge(object, [sources]) 參數\nobject (Object) : 目標物件 [sources] (\u0026hellip;Object) : 來源物件 返回\n(Object) : 返回 object 範例\nconst object = { \u0026#39;a\u0026#39;: [{ \u0026#39;b\u0026#39;: 2 }, { \u0026#39;d\u0026#39;: 4 }] }; const other = { \u0026#39;a\u0026#39;: [{ \u0026#39;c\u0026#39;: 3 }, { \u0026#39;e\u0026#39;: 5 }] }; _.merge(object, other); // =\u0026gt; { \u0026#39;a\u0026#39;: [{ \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3 }, { \u0026#39;d\u0026#39;: 4, \u0026#39;e\u0026#39;: 5 }] } 8. _.omit(object, [props]) 參數\nobject (Object) : 來源物件 [props] (\u0026hellip;(string|string[])) : 要被忽略的屬性。（註：單獨指定或指定在數組中。） 返回\n(Object) : 傳回新物件 範例\nconst object = { \u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: \u0026#39;2\u0026#39;, \u0026#39;c\u0026#39;: 3 }; _.omit(object, [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;]); // =\u0026gt; { \u0026#39;b\u0026#39;: \u0026#39;2\u0026#39; } 9. .omitBy(object, [predicate=.identity]) 參數\nobject (Object) : 來源物件 [predicate=_.identity] (Function) : 呼叫每一個屬性的函數 返回\n(Object) : 傳回新物件 範例\nconst object = { \u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: \u0026#39;2\u0026#39;, \u0026#39;c\u0026#39;: 3 }; _.omitBy(object, _.isNumber); // =\u0026gt; { \u0026#39;b\u0026#39;: \u0026#39;2\u0026#39; } 10. _.pick(object, [props]) 參數\nobject (Object) : 來源物件 [props] (\u0026hellip;(string|string[])) : 要被忽略的屬性。（註：單獨指定或指定在數組中。） 返回\n(Object) : 傳回新物件 範例\nconst object = { \u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: \u0026#39;2\u0026#39;, \u0026#39;c\u0026#39;: 3 }; _.pick(object, [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;]); // =\u0026gt; { \u0026#39;a\u0026#39;: 1, \u0026#39;c\u0026#39;: 3 } 11. .pickBy(object, [predicate=.identity]) 參數\nobject (Object) : 來源物件 [predicate=_.identity] (Function) : 呼叫每一個屬性的函數 返回\n(Object) : 傳回新物件 範例\nconst object = { \u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: \u0026#39;2\u0026#39;, \u0026#39;c\u0026#39;: 3 }; _.pickBy(object, _.isNumber); // =\u0026gt; { \u0026#39;a\u0026#39;: 1, \u0026#39;c\u0026#39;: 3 } 12. _.set(object, path, value) 參數\nobject (Object) : 要修改的物件 path (Array|string) : 要設定的物件路徑 value (*) : 要設定的值 返回\n(Object) : 返回 object 範例\nconst object = { \u0026#39;a\u0026#39;: [{ \u0026#39;b\u0026#39;: { \u0026#39;c\u0026#39;: 3 } }] }; _.set(object, \u0026#39;a[0].b.c\u0026#39;, 4); console.log(object.a[0].b.c); // =\u0026gt; 4 _.set(object, [\u0026#39;x\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;z\u0026#39;], 5); console.log(object.x[0].y.z); // =\u0026gt; 5 13. .transform(object, [iteratee=.identity], [accumulator]) 參數\nobject (Object) : 要遍歷的對象 [iteratee=_.identity] (Function) : 每次迭代時呼叫的函數 [accumulator] (*) : 定制疊加的值 返回\n(*) : 傳回疊加後的值 範例\nconst numbers = [1, 2, 3, 4, 5]; const sum = _.transform(numbers, (result, num) =\u0026gt; { result.sum += num; }, { sum: 0 }); console.log(sum); // =\u0026gt; { sum: 15 } 14. _.unset(object, path) 參數\nobject (Object) : 要修改的物件 path (Array|string) : 要移除的物件路徑 返回\n(boolean) : 如果移除成功，那麼返回 true，否則返回 false 範例\nconst object = { \u0026#39;a\u0026#39;: [{ \u0026#39;b\u0026#39;: { \u0026#39;c\u0026#39;: 7 } }] }; _.unset(object, \u0026#39;a[0].b.c\u0026#39;); // =\u0026gt; true console.log(object); // =\u0026gt; { \u0026#39;a\u0026#39;: [{ \u0026#39;b\u0026#39;: {} }] }; _.unset(object, [\u0026#39;a\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]); // =\u0026gt; true console.log(object); // =\u0026gt; { \u0026#39;a\u0026#39;: [{ \u0026#39;b\u0026#39;: {} }] }; 15. _.values(object) 參數\nobject (Object) : 要檢索的物件 返回\n(Array) : 傳回物件屬性的值的陣列 範例\nconst object = { a: 1, b: 2, c: 3 }; const values = _.values(object); console.log(values); // =\u0026gt; [1, 2, 3] 字串 1. _.replace([string=\u0026rsquo;\u0026rsquo;], pattern, replacement) 參數\n[string=\u0026rsquo;\u0026rsquo;] (string) : 待替換的字串 pattern (RegExp|string) : 要符合的內容 replacement (Function|string) : 替換的內容 返回\n(string) : 傳回替換後的字串 範例\n_.replace(\u0026#39;Hi Fred\u0026#39;, \u0026#39;Fred\u0026#39;, \u0026#39;Barney\u0026#39;); // =\u0026gt; \u0026#39;Hi Barney\u0026#39; 2. _.split([string=\u0026rsquo;\u0026rsquo;], separator, [limit]) 參數\n[string=\u0026rsquo;\u0026rsquo;] (string) : 要拆分的字串 separator (RegExp|string) : 拆分的分隔符號 [limit] (number) : 限制結果的數量 返回\n(Array) : 傳回拆分部分的字串的陣列 範例\n_.split(\u0026#39;a-b-c\u0026#39;, \u0026#39;-\u0026#39;, 2); // =\u0026gt; [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;] 3. _.trim([string=\u0026rsquo;\u0026rsquo;], [chars=whitespace]) 參數\n[string=\u0026rsquo;\u0026rsquo;] (string) : 要處理的字串 [chars=whitespace] (string) : 要移除的字元 返回\n(string) : 傳回處理後的字串 範例\n_.trim(\u0026#39; abc \u0026#39;); // =\u0026gt; \u0026#39;abc\u0026#39; _.trim(\u0026#39;-_-abc-_-\u0026#39;, \u0026#39;_-\u0026#39;); // =\u0026gt; \u0026#39;abc\u0026#39; _.map([\u0026#39; foo \u0026#39;, \u0026#39; bar \u0026#39;], _.trim); // =\u0026gt; [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;] 實用函數 1. _.flow([funcs]) 參數\n[funcs] (\u0026hellip;(Function|Function[])) : 要呼叫的函數 返回\n(Function) : 傳回新的函數 範例\nconst idsStr = _.flow( () =\u0026gt; _.map(listings, \u0026#39;id\u0026#39;), ids =\u0026gt; _.join(ids, \u0026#39;，\u0026#39;) )() 2. _.range([start=0], end, [step=1]) 參數\n[start=0] (number) : 開始的範圍 end (number) : 結束的範圍 [step=1] (number) : 範圍的增量或減量 返回\n(Array) : 傳回範圍內數字組成的新陣列 範例\n_.range(4); // =\u0026gt; [0, 1, 2, 3] _.range(-4); // =\u0026gt; [0, -1, -2, -3] _.range(1, 5); // =\u0026gt; [1, 2, 3, 4] _.range(0, 20, 5); // =\u0026gt; [0, 5, 10, 15] _.range(0, -4, -1); // =\u0026gt; [0, -1, -2, -3] _.range(1, 4, 0); // =\u0026gt; [1, 1, 1] _.range(0); // =\u0026gt; [] 3. .times(n, [iteratee=.identity]) 參數\nn (number) : 呼叫iteratee的次數 [iteratee=_.identity] (Function) : 每次迭代呼叫的函數 返回\n(Array) : 傳回呼叫結果的陣列 範例\n_.times(3, String); // =\u0026gt; [\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;] _.times(4, _.constant(0)); // =\u0026gt; [0, 0, 0, 0] 結語 關於 Lodash 筆記會持續更新～\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/11/lodash-introduction/","tags":["Lodash"],"title":"Lodash Introduction"},{"categories":["Notes"],"contents":"前言 E2E 測試在模擬真實用戶在應用程式中的實際使用情境，驗證各個組件之間功能是否正常。\n主要測試目標如下：\n驗證應用功能：測試將模擬用戶與應用程式的互動情境，例如填寫表單、點擊按鈕、導航到不同頁面等，以確保所有功能正常運作。\n測試使用者界面（UI）：測試使用者界面，以確保 UI 元素的正確性和可用性。這包括驗證頁面佈局、樣式、互動和使用者體驗。\n跨瀏覽器和跨平台兼容性：測試不同的瀏覽器和操作系統上運行，以確保應用程式在各種環境中都能正常運作。這有助於發現和解決跨瀏覽器和跨平台兼容性問題。\n性能測試：測試應用程式的性能，例如加載時間、響應時間和並發用戶支援。這有助於發現性能瓶頸和優化機會。\n視覺測試：驗證應用程式的用戶界面（UI）外觀和布局是否正確的測試方法。它的主要目標是檢測潛在的 UI 問題，例如樣式錯誤、布局差異、文本溢出等，以確保應用程式的 UI 在不同環境和設備上都能夠正確呈現。前公司為例是用頁面截圖比對。\n以下 E2E 測試會使用自動化測試框架CodeceptJS來模擬用戶行為。\n管理（Page Objects）模組化 可建立pageObjects.js，裡面 exportspageObject函數用來簡化頁面對象的管理和使用，提高腳本可讀性。\n// pageObjects.js // 可針對選擇器命名 const pageObjects = { topNav: [\u0026#39;.top-nav\u0026#39;, \u0026#39;Top Navigation\u0026#39;], logoutBtn: [\u0026#39;#logoutBtn\u0026#39;, \u0026#39;Logout Button\u0026#39;] infoBlock: [\u0026#39;[data-role=\u0026#34;info-block\u0026#34;]\u0026#39;, \u0026#39;info block\u0026#39;] } const pageObject = (name) =\u0026gt; { const selectedPageObject = pageObjects[name] if (!selectedPageObject) { const msg = `❌ PAGE OBJECT ERROR: \u0026#34;${name}\u0026#34; is not defined!` throw new Error(msg) } if (!selectedPageObject[2]) { console.log(`✅ pageObject(\u0026#39;${name}\u0026#39;) =\u0026gt; \u0026#39;${selectedPageObject[0]}\u0026#39; // ${selectedPageObject[1]}`) selectedPageObject[2] = 1 } return selectedPageObject[0] } module.exports = { pageObject } 如何應用 pageObject 以下範例示範用pageObject('topNav')，就可取得pageObjects定義的元素。\nFeature(\u0026#39;Navigation @pc @noie @nosafari @nofirefox\u0026#39;) const pageObject = require(\u0026#39;./pageObjects\u0026#39;).pageObject Scenario(\u0026#39;open dashboard, see navigation sections\u0026#39;, ({ I }) =\u0026gt; { I.amOnPage(\u0026#39;/dashboard\u0026#39;) I.seeElement(pageObject(\u0026#39;topNav\u0026#39;)) }) codecept.conf.js 配置 以下是常見的WebDriver和Puppeteer配置，可參考 configuration。\nexports.config = { tests: \u0026#39;./tests/*.js\u0026#39;, output: \u0026#39;./output\u0026#39;, helpers: { WebDriver: { url: \u0026#39;https://example.com\u0026#39;, // 設定要測試的網站 URL browser: \u0026#39;chrome\u0026#39;, // 選擇瀏覽器（可以是 chrome、firefox、edge 等） windowSize: \u0026#39;1920x1080\u0026#39;, // 設定瀏覽器視窗大小 }, Puppeteer: { url: \u0026#39;https://example.com\u0026#39;, // 設定要測試的網站 URL show: false, // 是否顯示瀏覽器視窗 windowSize: \u0026#39;1920x1080\u0026#39;, // 設定瀏覽器視窗大小 }, }, include: { I: \u0026#39;./steps_file.js\u0026#39;, }, bootstrap: null, mocha: {}, name: \u0026#39;我的測試專案\u0026#39;, plugins: { wdio: { enabled: true, services: [\u0026#39;selenium-standalone\u0026#39;], }, }, multiple: { parallel: { chunks: 2, }, }, screenshotPath: \u0026#39;./output/screenshots\u0026#39; } Visual Testing CodeceptJS 使用WebDriver幫助程式和Selenium來自動化瀏覽器。它還能夠截取應用程式的螢幕截圖，這可用於視覺測試，可參考官方文件。\n方法：在codecept.conf.js新增配置，指定截圖目錄路徑。\nscreenshotPath: \u0026#39;./output/screenshots\u0026#39; 使用：\nFeature(\u0026#39;視覺測試\u0026#39;); Scenario(\u0026#39;檢查頁面外觀\u0026#39;, (I) =\u0026gt; { I.amOnPage(\u0026#39;https://example.com\u0026#39;); // 執行一些操作... // 生成並截圖至 screenshots 資料夾 I.saveScreenshot(\u0026#39;my-screenshot.png\u0026#39;); }); 自定義 Helper 配置 可以在codecept.conf.js，自定 Helper。\n範例：CustomHelper\nexports.config = { helpers: { WebDriver: { // 配置 WebDriver Helper url: \u0026#39;http://example.com\u0026#39;, browser: \u0026#39;chrome\u0026#39;, }, CustomHelper: { // 配置 CustomHelper apiKey: \u0026#39;your_api_key_here\u0026#39;, }, }, // ... }; 如何使用\nclass CustomHelper { constructor(config) { this.options = config; // 訪問自定義 Helper 的配置選項 } async performCustomTask() { const apiKey = this.options.apiKey; // 使用 apiKey } } module.exports = CustomHelper; 結語 關於 E2E Testing 筆記會持續更新～\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/11/react-e2e-testing/","tags":["React.js","CodeceptJS","Puppeteer","webdriver"],"title":"End-to-End (E2E) Testing"},{"categories":["Notes"],"contents":"前言 紀錄一些重點\n使用 Jest 進行快照測試 每當您想要確保 UI 不會意外更改時，快照測試都是一個非常有用的工具。\n第一次執行此測試時，Jest 會在__tests__目錄內建立__snapshots__目錄，裡面建立一個 snapshot 檔案，檔名會是測試檔的名稱再加上.snap，當 UI 有變更的時候，Snapshot 就會顯示異動的部分。\n執行指令npm run test -- -u，覆蓋原本就的，產生新的 Snapshot。\n範例 // Button.js import React from \u0026#39;react\u0026#39;; const Button = ({ label }) =\u0026gt; ( \u0026lt;button\u0026gt;{label}\u0026lt;/button\u0026gt; ); export default Button; // __tests__/Button.test.js import React from \u0026#39;react\u0026#39;; import renderer from \u0026#39;react-test-renderer\u0026#39;; import Button from \u0026#39;./Button\u0026#39;; test(\u0026#39;Button component snapshot\u0026#39;, () =\u0026gt; { const component = renderer.create(\u0026lt;Button label=\u0026#34;Click Me\u0026#34; /\u0026gt;); const tree = component.toJSON(); expect(tree).toMatchSnapshot(); }); 示意快照內容如下\n// 例如：Button.test.js.snap exports[`Button component snapshot 1`] = ` \u0026lt;button\u0026gt; Click Me \u0026lt;/button\u0026gt; ` 測試覆蓋率報告（Coverage Reporting） 執行npm run test -- --coverage就可以取得測試覆蓋率的報告。如要修改配置可以參考 configuration 的部分。\njest.config.js 常用配置 testRegex 用來匹配測試文件的路徑和文件名\n範例：\ntestRegex: \u0026#39;__tests__/.*\\\\.?(spec|test)\\\\.js?$\u0026#39; testRegex 可以指定處理格式黨\n範例：\nmoduleFileExtensions: [\u0026#39;js\u0026#39;, \u0026#39;jsx\u0026#39;, \u0026#39;json\u0026#39;] transform 可指定哪些文件該如何轉換\n範例：\ntransform: { \u0026#39;\\\\.js$\u0026#39;: [ \u0026#39;es-jest\u0026#39;, { jsxDev: true, jsx: \u0026#39;automatic\u0026#39;, loader: \u0026#39;jsx\u0026#39; } ] } setupFiles 運行測試初始化配置\n範例：\nsetupFiles: [\u0026#39;\u0026lt;rootDir\u0026gt;/__tests__/setup/init.js\u0026#39;] testEnvironment 指定測試運行環境，預設默認jsdom\n範例：\ntestEnvironment: \u0026#39;jsdom\u0026#39; coverageThreshold 用於設定測試覆蓋率值\n範例：\ncoverageThreshold: { global: { statements: 80, branches: 80, functions: 80, lines: 80, }, } moduleNameMapper 可指定模塊路徑該到哪裡\n範例：\n\u0026#39;@storybook/addon-docs/(.*)\u0026#39;: \u0026#39;@storybook/addon-docs/dist/cjs/$1\u0026#39;, \u0026#39;@vzmi/ec_file_uploader_sdk\u0026#39;: \u0026#39;\u0026lt;rootDir\u0026gt;/__mocks__/file-uploader-sdk.js\u0026#39;, \u0026#39;uuid/v1\u0026#39;: \u0026#39;\u0026lt;rootDir\u0026gt;/__mocks__/uuidv1.js\u0026#39; collectCoverage 啟用覆蓋率報告\n範例：\ncollectCoverage: true collectCoverageFrom 指定哪些文件應包括在測試覆蓋率報告中\n範例：\ncollectCoverageFrom: [\u0026#39;src/**/*.{js,jsx}\u0026#39;] reporters 生成測試報告生成測試報告的方式和格式\n範例：\nreporters: [\u0026#39;default\u0026#39;, \u0026#39;jest-junit\u0026#39;] coveragePathIgnorePatterns 配置覆蓋率報告需要忽略的路徑\n範例：\ncoveragePathIgnorePatterns: [ \u0026#39;\u0026lt;rootDir\u0026gt;/conf/\u0026#39;, \u0026#39;\u0026lt;rootDir\u0026gt;/__tests__/config/\u0026#39;, \u0026#39;\u0026lt;rootDir\u0026gt;/__tests__/support/\u0026#39; ] testPathIgnorePatterns 測試需要忽略的路徑\n範例：\ntestPathIgnorePatterns: [ \u0026#39;\u0026lt;rootDir\u0026gt;/node_modules/\u0026#39;, \u0026#39;\u0026lt;rootDir\u0026gt;/__tests__/config/\u0026#39; ] globals 全局變量\n範例：\nglobals: { __DEV__: true } setupFilesAfterEnv 測試環境初始化後執行\n範例：\nsetupFilesAfterEnv: [ \u0026#39;\u0026lt;rootDir\u0026gt;/node_modules/raf/polyfill\u0026#39;, \u0026#39;\u0026lt;rootDir\u0026gt;/node_modules/regenerator-runtime/runtime\u0026#39;, \u0026#39;\u0026lt;rootDir\u0026gt;/__tests__/config/setup.js\u0026#39;, ] testRunner 指定 Jest 使用的運行器\n範例：\ntestRunner: \u0026#39;jest-jasmine2\u0026#39; maxWorkers 配置 Jest 啟動後最大工作進程數，提高測試速度\n範例：\nmaxWorkers: \u0026#39;50%\u0026#39; jest.fn() 創建一個 mock function，可模擬函數被調用，也可設置返回值\n// 創建一個模擬函數 const mockFunction = jest.fn(); // 設定模擬函數返回值 mockFunction.mockReturnValue(42); // 調用模擬函數 const result = mockFunction(); // 測試模擬函數被調用一次 expect(mockFunction).toBeCalledTimes(1); // 測試模擬函數返回值為 42 expect(result).toBe(42); 結語 關於 Jest 筆記會持續更新～\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/11/react-jest/","tags":["React.js","Jest"],"title":"Use Jest"},{"categories":["Notes"],"contents":"前言 React Testing Enzyme 主要介紹幾個方法：shallow、render、mount。\n函數 渲染範圍 子元件渲染 事件模擬 shallow 只渲染元件本身 不渲染子元件 支援事件模擬 render 產生靜態 HTML 字串 不在真實 DOM 渲染 不支援事件模擬 mount 渲染整個 React 樹 渲染所有子元件 支援事件模擬 範例 使用shallow函數： 情境：測試一個 React 按鈕元件的點擊事件處理，而不需要渲染其子元件。\nimport React from \u0026#39;react\u0026#39;; import { shallow } from \u0026#39;enzyme\u0026#39;; const MyButton = ({ onClick }) =\u0026gt; ( \u0026lt;button onClick={onClick}\u0026gt;Click me\u0026lt;/button\u0026gt; ); describe(\u0026#39;MyButton\u0026#39;, () =\u0026gt; { it(\u0026#39;should handle click event using shallow\u0026#39;, () =\u0026gt; { const onClickMock = jest.fn(); const wrapper = shallow(\u0026lt;MyButton onClick={onClickMock} /\u0026gt;); wrapper.find(\u0026#39;button\u0026#39;).simulate(\u0026#39;click\u0026#39;); expect(onClickMock).toHaveBeenCalled(); }); }); 使用render函數： 情境：測試一個 React 文字元件的渲染結果，並確保它以特定方式呈現，但不需要模擬事件處理。\nimport React from \u0026#39;react\u0026#39;; import { render } from \u0026#39;enzyme\u0026#39;; const Greeting = ({ name }) =\u0026gt; ( \u0026lt;div\u0026gt;Hello, {name}!\u0026lt;/div\u0026gt; ); describe(\u0026#39;Greeting\u0026#39;, () =\u0026gt; { it(\u0026#39;should render greeting message using render\u0026#39;, () =\u0026gt; { const renderedComponent = render(\u0026lt;Greeting name=\u0026#34;John\u0026#34; /\u0026gt;); expect(renderedComponent.text()).toBe(\u0026#39;Hello, John!\u0026#39;); }); }); 使用mount函數： 情境：測試一個包含多個子元件的 React 表單，包括模擬事件處理和子元件的互動。\nimport React from \u0026#39;react\u0026#39;; import { mount } from \u0026#39;enzyme\u0026#39;; const Form = ({ onSubmit }) =\u0026gt; ( \u0026lt;form onSubmit={onSubmit}\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ); describe(\u0026#39;Form\u0026#39;, () =\u0026gt; { it(\u0026#39;should handle form submission using mount\u0026#39;, () =\u0026gt; { const onSubmitMock = jest.fn(); const wrapper = mount(\u0026lt;Form onSubmit={onSubmitMock} /\u0026gt;); const usernameInput = wrapper.find(\u0026#39;input[name=\u0026#34;username\u0026#34;]\u0026#39;); const passwordInput = wrapper.find(\u0026#39;input[name=\u0026#34;password\u0026#34;]\u0026#39;); const submitButton = wrapper.find(\u0026#39;button\u0026#39;); usernameInput.simulate(\u0026#39;change\u0026#39;, { target: { value: \u0026#39;user123\u0026#39; } }); passwordInput.simulate(\u0026#39;change\u0026#39;, { target: { value: \u0026#39;password123\u0026#39; } }); submitButton.simulate(\u0026#39;submit\u0026#39;); expect(onSubmitMock).toHaveBeenCalledWith({ username: \u0026#39;user123\u0026#39;, password: \u0026#39;password123\u0026#39;, }); }); }); 結語 總結一下：\nshallow 函數：\n使用 shallow 函數時，它只渲染被測試元件本身，不渲染其子元件。 主要用於測試被測試元件的行為，而不關心子元件的情況。 可以模擬事件處理，用於測試點擊事件、輸入事件等。 render 函數：\nrender 函數將元件渲染成靜態 HTML 字串，但不在真實 DOM 中渲染。 主要用於測試元件的渲染結果，以及進行快照測試。 不支援事件模擬，因為它不在真實 DOM 中渲染。 mount 函數：\n使用 mount 函數時，它會渲染整個 React 樹，包括子元件。 主要用於進行完整的測試，包括事件處理、互動和子元件渲染的情況。 可以模擬事件處理，用於測試點擊事件、輸入事件等。 可以根據測試需求選擇適當的函數，以確保測試覆蓋到你的應用程式中不同情境下的需求。\n以上是我在工作期間整理Enzyme幾個基本用法。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/11/react-testing-enzyme/","tags":["React.js","Jest","Testing Library"],"title":"React Testing Enzyme"},{"categories":["Notes"],"contents":"前言 React Testing Library 主要提供幾個方法：render、fireEvent、screen、waitFor。\n前置設定需搭配 @testing-library/jest-dom。\n什麼時候該用此 Library 可參考官方Solution render 用於渲染 React 組件到虛擬 DOM 中，並返回一個包含渲染結果的容器對象。\nfireEvent 用於模擬 DOM 事件，例如點擊、輸入文字、提交表單等。這可用於觸發元素上的事件，以模擬使用者操作。\nscreen 提供了一組方法來查找 DOM 元素，以進行測試操作。\nwaitFor 用於等待異步操作完成，通常用於等待數據載入、渲染完成或狀態更新。\n範例 以下測試測試按鈕點擊後是否正確顯示文字流程。\n// ButtonComponent.js import React, { useState } from \u0026#39;react\u0026#39;; function ButtonComponent() { const [isClicked, setIsClicked] = useState(false); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setIsClicked(true)}\u0026gt;Click Me\u0026lt;/button\u0026gt; {isClicked \u0026amp;\u0026amp; \u0026lt;p\u0026gt;Button was clicked!\u0026lt;/p\u0026gt;} \u0026lt;/div\u0026gt; ); } export default ButtonComponent; import React from \u0026#39;react\u0026#39;; import { render, fireEvent, screen, waitFor } from \u0026#39;@testing-library/react\u0026#39;; import ButtonComponent from \u0026#39;./ButtonComponent\u0026#39;; test(\u0026#39;測試按鈕點擊後是否正確顯示文字\u0026#39;, async () =\u0026gt; { // 渲染組件 render(\u0026lt;ButtonComponent /\u0026gt;); // 首先確保文字元素不可見 expect(screen.queryByText(\u0026#39;Button was clicked!\u0026#39;)).toBeNull(); // 找到按鈕元素 const button = screen.getByText(\u0026#39;Click Me\u0026#39;); // 模擬點擊按鈕 fireEvent.click(button); // 使用 waitFor 等待直到文字元素出現 await waitFor(() =\u0026gt; { expect(screen.getByText(\u0026#39;Button was clicked!\u0026#39;)).toBeInTheDocument(); }); }); 結語 以上是我在工作期間整理react-testing-library幾個基本用法，如果需更深入了解可到官方文件學習。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/11/react-testing-library/","tags":["React.js","Jest","Testing Library"],"title":"React Testing Library"},{"categories":["Notes"],"contents":"前言 React Hooks Testing Library 主要提供三個方法：renderHook、act、cleanup。\n什麼時候該用此 Library 官方Solution 使用\n當寫一個函式庫，且 Hooks 並不是只在某個對應的元件中被使用 Hook 非常複雜，很難透過組件互動進行測試 不要使用\nHook 只給某對應的元件使用時 Hook 非常容易測試，只需要直接針對元件進行測試即可 renderHook 如果要取得 hook 的回傳值，可透過result.current取得當前最新的值。\nact 當 hook 內部 state 改變時（例如，setXXX），需要把這個方法包在 act 後才加以呼叫。\ncleanup 用來清理測試環境，用法cleanup()。\n範例 測試useUIState的初始狀態和狀態更新時，是否都可正常工作。\n以下測試三種狀態pageFlow、isLoading、isPending。\n// useUIState.js import { useReducer } from \u0026#39;react\u0026#39; // 定義操作類型 const ACTIONS = { SET_PAGE_FLOW: \u0026#39;SET_PAGE_FLOW\u0026#39;, SET_IS_LOADING: \u0026#39;SET_IS_LOADING\u0026#39;, SET_IS_PENDING: \u0026#39;SET_IS_PENDING\u0026#39; } // 初始化狀態 const getInitState = props =\u0026gt; { const { match: { params: { phase } } } = props return { pageFlow: phase, isLoading: false, isPending: false } } // 自定義 Hook const useUIState = props =\u0026gt; { const reducer = (state, action) =\u0026gt; { const { type, payload } = action switch (type) { case ACTIONS.SET_PAGE_FLOW: return { ...state, pageFlow: payload } case ACTIONS.SET_IS_LOADING: return { ...state, isLoading: payload } case ACTIONS.SET_IS_PENDING: return { ...state, isPending: payload } default: return state } } // 使用 useReducer 管理狀態 const [state, dispatch] = useReducer(reducer, props, getInitState) // dispatch 觸發狀態更新操作 const setPageFlow = pageFlow =\u0026gt; dispatch({ type: ACTIONS.SET_PAGE_FLOW, payload: pageFlow }) const setIsLoading = isLoading =\u0026gt; dispatch({ type: ACTIONS.SET_IS_LOADING, payload: isLoading }) const setIsPending = isPending =\u0026gt; dispatch({ type: ACTIONS.SET_IS_PENDING, payload: isPending }) const actions = { setPageFlow, setIsLoading, setIsPending } return { state, actions } } export default useUIState 可以看到第一個check initial state測試，假設renderHook取得props回傳值，並確認result.current.state是跟預期initialState相同。\n而第二個test actions works測試，透過act模擬更新狀態，最後檢查當前狀態是否跟updatedState相同。\n// useUIState.test.js import { renderHook, act } from \u0026#39;@testing-library/react-hooks\u0026#39; import useUIState from \u0026#39;./useUIState\u0026#39; // flowTypes export const PAGE_FLOW = { INITIAL: \u0026#39;initial\u0026#39;, EDIT: \u0026#39;edit\u0026#39;, CONFIRM: \u0026#39;confirm\u0026#39;, SUCCESS: \u0026#39;success\u0026#39;, ERROR: \u0026#39;error\u0026#39; } describe(\u0026#39;useUIState\u0026#39;, () =\u0026gt; { const props = { match: { params: { phase: PAGE_FLOW.INITIAL } } } it(\u0026#39;check initial state\u0026#39;, () =\u0026gt; { const { result } = renderHook(() =\u0026gt; useUIState(props)) const initialState = { pageFlow: PAGE_FLOW.INITIAL, isLoading: false, isPending: false } expect(result.current.state).toEqual(initialState) }) it(\u0026#39;test actions works\u0026#39;, () =\u0026gt; { const { result } = renderHook(() =\u0026gt; useUIState(props)) const updatedState = { pageFlow: PAGE_FLOW.ERROR, isLoading: true, isPending: true } act(() =\u0026gt; { result.current.actions.setIsLoading(updatedState.isLoading) result.current.actions.setIsPending(updatedState.isPending) result.current.actions.setPageFlow(updatedState.pageFlow) }) expect(result.current.state).toEqual(updatedState) }) }) 結語 以上是我在工作期間整理react-hooks-testing-library幾個基本用法，如果需更深入了解可到官方文件學習。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/11/react-hooks-testing-library/","tags":["React.js","Jest","Testing Library"],"title":"React Hooks Testing Library"},{"categories":["Notes"],"contents":"前言 這是一個物業管理，其中也有硬體端整合，這套系統從零到現在正式上線，我全程參與，包含事前規劃流程設計、UI討論。\n技術架構 前後端分離，前端用 React.js 開發及 icejs+(fusion/antd)UI，完成管理者後台介面\u0008及 APP 使用者介面 使用 Feathers 框架創建 REST API 和 WebSocket 與後端溝通，帳號權限處理、帳號登入登出機制 資料庫使用 MongoDB 使用 Docker-compose 部屬到公司購買實體主機 功能介紹 使用者APP介面 帳號設置：綁定社區、QRCode掃描或帳密登入建立帳號。\n個人首頁：平台手冊下載、各項功能Icon(點擊可至該頁面)、推播紀錄通知、推播紀錄通知、帳號設定、畫板(可下載or儲存照片)。\n通知訊息：公告、行事曆、訪客、包裹 、寄物、投票、報修、公設預約、BA系統 等\u0026hellip;通知。\n個人設置：住戶開通條碼、用戶頭像、暱稱、密碼修改。\n系統設置：各項推播設置、一鍵推播。\n公告事項：類別篩選、公告細項頁、檔案及圖片preview及download。\n行事曆：行事曆UI、檔案及圖片preview及download。\n郵件包裹：查看包裹紀錄、條碼(可給警衛掃描)、條件篩選。\n寄物管理：查看寄物紀錄、條件篩選。\n公設預約：公設資訊、公設預約表單、紀錄查詢、取消預約。\n訪客門禁：訪客預約表單、紀錄查詢、取消登記、轉發Line。\n投票活動：投票資訊、checkbox選項、投票統計。\n報修服務：新增報修表單、檔案上傳、狀態進度、回覆內容。\n瓦斯抄錶：抄錶登記表單、檔案上傳。\n意見反應：新增表單、檔案上傳。\n智慧信箱：查看信箱狀態、遠端開啟信箱。\n家庭保全：開啟關閉保全。\n身體量測：個人血壓、身高體重資料、圖表統計。\nBA 系統：遠端開關電燈、窗簾、門口機、大門、信箱、BA裝置\u0026hellip;等。\n汽車充電樁：顯示圖表、紀錄等。\n智慧建築專區：各文件顯示。\n後台管理 (CRUD＝指列表新增、查詢、更新、刪除的功能) 首頁：下載教學手冊、推播紀錄通知、功能選單、帳號設定、全屏切換。\n個人設置：可更換大頭貼、暱稱、重設密碼。\n系統設置：各項功能推播設置。\n登入註冊：帳密登入、註冊帳號。\n通知訊息：通知紀錄、查看、已讀模式。\n公告事項：公告(CRUD)、置頂、推播各戶(棟)功能、類別搜尋。\n行事曆：行事曆(CRUD)、推播。\n郵件包裹：包裹(CRUD)、領取包裹方式(掃描APP條碼、磁扣、卡片)、拍照、簽名、通知住戶(APP通知)、退貨、紀錄。\n寄物管理：寄物(CRUD)、領取包裹方式(掃描APP條碼、磁扣、卡片)、通知住戶 (APP通知)、紀錄。\n訪客管理：訪客(CRUD)、訪客統計、訪客車牌管理、訪客辨識管理、訪客卡管理、 訪客進場離開開關。\n公設預約：公設(CRUD)、紀錄、時段預約、計次預約。\n投票活動：投票(CRUD)、設定問題選項。\n報修服務：報修(CRUD)、報修進度、回報表單、通知住戶。\n瓦斯抄錶：抄錶(CRUD)、下載住戶抄錶資料。\n意見反應：意見(CRUD)、通知住戶、回覆進度內容。\n智慧信箱：各住戶紀錄、開啟信箱、投信狀態。\nBA 系統：裝置(CRUD)、紀錄、匯出匯入Excel、門禁權限管理。\n財務管理：住戶財務、社區財務、下載報表、產生帳單(未開發完成)。\n智慧建築專區：資產管理、效能管理、維運管理、組織管理、文件檔案管理。\n社區管理：戶號(CRUD)、匯入匯出資料、下載範例表單、下載QR Code、住戶開通、社區基本資料、訊息推播。\n帳號管理：使用者帳號(CRUD)、開通帳號、權限設定、頁面權限設定。\n結語 從 O 到上線的專案做完蠻有成就感🥰\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/11/property-notes/","tags":["React.js","Feathers","MongoDB"],"title":"物業系統"},{"categories":["Portfolio"],"contents":"前言 是一個在「資策會」做的專題，從規劃、設計、實作、發表，總共花了一個多月時程。\n使用技術及工具 設計/原形工具：Illustrator、Adobe XD 前端技術：HTML、CSS、SCSS、JavaScript 前端框架：React.js 後端技術：Node.js、Express 資料庫運用：MySQL 版本控制：GitHub 套件技術：axios、node-sass、react-redux、redux-persist、redux-saga、reselect 編輯器技術： VS Code 功能說明： 首頁 會員登入註冊 會員中心系統 商城\u0026amp;購物車系統 結帳\u0026amp;訂單系統 課程預約系統 教練中心系統 心得討論區系統 客服中心系統 網站功能介紹 首頁 會員登入註冊 會員中心系統 登入後，即可進入會員中⼼，提供會員資料修改並管理購買清單以及查詢已報名之課程、⽂章管理以及客訴紀錄。\n商城\u0026amp;購物車系統 提供商品的篩選以及價格排序的功能。\n商品點擊提供更細項內容。\n可加入收藏清單及購物車。\n結帳\u0026amp;訂單系統 結帳分為確認清單、填寫付款方式及完成頁。\n可查看訂購紀錄。\n課程預約系統 可預約課程、資訊瀏覽並有人數額滿限制提示。\n教練中心系統 提供上下架課程功能。\n心得討論區系統 提供發表文章、篩選文章、留言、按讚等功能。\n客服中心系統 Q\u0026amp;A瀏覽、客訴表單、即時問答等功能。\n結語 以下是我的分工\n前端：討論區首頁、文章細節頁、文章上下架及編輯頁、會員管理文章紀錄\n後端：MySQL⽂章資料表設計及會員、⽂章API及路由設計\n其他：專題簡報製作、整合組員程式碼、UI設計\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/11/portfolio-wow-fit/","tags":["React.js","Redux","MySQL","Node.js"],"title":"複合型健身房官方網站「WoW FIT」"},{"categories":["Portfolio"],"contents":"前言 這是我練習用 React Native 來寫 App，並使用 Expo 呈現\n以下用 Expo 線上工具 Demo 進到 Expo 可以針對不同 Device 查案 以下環境是 iOS 遊戲規則：直到全部配對成功\n結語 重 0 開始建置 React Native ，讓我更清楚架構。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/11/portfolio-match-game/","tags":["React Native"],"title":"Matching Game"},{"categories":["Portfolio"],"contents":"前言 之前在前公司有用到 Line shareTargetPicker API 的應用，用來發送訪客 QR code 給 Line 好友，這邊做一個簡單 Demo，單純轉發當前 URL 給好友。\nLine LIFF ShareTargetPicker 教學 步驟 1：進到 developerse官網 建立 channel 選擇 Products，請選擇LINE Login，然後Create a new channel\n步驟 2：建立 LIFF 這時點選頁籤LIFF按下Add。\n以下說明 LIFF 表單\nSize：這一項有三個值 Full、Tall、Compact，說明 LINE 打開 LIFF 時，他的大小要多大。 要注意的是，分享的按鈕只會在「Full」這個 Size 出現。\nEndpoint URL ：使用者點擊了 LIFF 的連結，實際上 LIFF 是開啟了哪個頁面。\nScopes ：指的是我們想要取哪些資料，「chat_message.write」，這項是如果要用到主動幫使用者發訊息的 sendMessages 函式時，這邊就必須打勾，不然 sendMessages 就無法使用。\nAdd friend option ：當使用者要登入我們建立的 LIFF 時，要怎麼推薦他加入我們的 LINE。\nScan QR ：指要不要使用 LIFF 的打開 QR code 掃描器功能。\n步驟 3：建立 LIFF 完成 建立完成後記得勾選shareTargetPicker，這項功能是主動讓使用者發送我們指定的訊息給他的好友。\nLIFF ID這個要先記起來，之後寫 JS 用到。\n步驟 4：LIFF 轉成公開 進到 LINE Developers 的後台，進到我們創建的 LIFF，會有一個Developing的按鈕，需要按下Publish就會轉成公開\n程式碼參考範例 Demo 影片 結語 主要是可以讓使用者用 Line 就可以快速分享該頁面。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/10/portfolio-line-sharetargetpicker/","tags":["Line"],"title":"Line LIFF ShareTargetPicker"},{"categories":["Portfolio"],"contents":"前言 依照個人喜好做出各種風格的機器人像是 AI 聊天，接收到的文字另存至資料庫等\n建立 Line bot 步驟 1：在 LINE Developers 登入自己Line帳號 步驟 2：建立 line 頻道 選擇 Messaging API\n步驟 3：將帳號加為好友 建立好 channel，可在第二個頁籤Messaging API看到Bot basic ID，這就是新增好友的 ID，也可以掃QR code。\n步驟 4：設定 Webhook 往下滑會看到Webhook settings，把Use webhook打開，上方的 URL可以先不輸入，等等再回來設定。\n步驟 5：記下程式連接Bot必要的密鑰 這兩個到時候我是添加到程式中.env的設定。\nBasic settings — Channel secret Messaging API — Channel access token 步驟 6：設定自動回覆及打招呼 在Messaging API頁籤拉到下面會看到LINE Official Account features，點選Auto-reply messages右邊的編輯可以設定。\n回應設定就看個人需求，我這邊都是打開。\n建立聊天機器人專案 這邊我是用 Node.js + MongoDB Atlas 部署到 Render\n以下是撰寫 Node.js 程式筆記 步驟 1：安裝@line/bot-sdk這個套件，並在專案底下建立一個app.js的檔案 npm i @line/bot-sdk express dotenv 步驟 2：撰寫 LINE Bot 不外乎前面就是引入@line/bot-sdk、express與dotenv這三個套件，Line 官方有提供範例程式碼。\n步驟 3：建立.env，並寫下創建 LineBot 的密鑰channelSecret及channelAccessToken。 部署至 Render 步驟 1：到官網註冊，並 Connect GitHub 步驟 2：選擇要部署的專案 點選Web Services\n設置Configure account，選擇 LineBot 專案\n步驟 3：Connect 要部署的專案 點擊Connect\n步驟 4：填寫部署資訊 步驟 5：選擇收費方案 這裡我選Free\n步驟 6：「Advanced」區塊填入環境變數 點一下「Add Environment Variable」，依照欄位填入\n步驟 7：Create Web Service 這時候就會開始進行部署\n回到 line 設定 webhook 到dashboard選擇想要的services name，進去後左上角會看見一串URL，這就是需要設定在 line webhook。\n記得要加上/callback。\n小皮妞Bot Demo 打開指令介紹：** 增加紀錄：@標題@內容 搜詢當下關鍵字：@@關鍵字 刪除當下第N筆文章：@$N 輸出當下\u0026quot;文章編號(第N*10筆)：$$$N 輸出當下第N筆文章：$$N 輸出自己\u0026quot;文章編號(第N*10筆)：$$$myN 可以群聊針對自己文章查詢 輸出不存在指令：可以隨便打測試 結語 Heroku 轉移至 Fly.io，讓我的小皮妞Bot復活，但莫名其妙被多收錢，因此再轉移至 Render。\n而 Render 優點：\n有免費計畫，且不用先綁信用卡，用起來比較安心\n每個月免費 500 分鐘建構，和 450 小時免費使用時數\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/10/portfolio-qq-linebot/","tags":["Render","LineBot","Line"],"title":"LineBot 關鍵字儲存查詢"},{"categories":["Notes"],"contents":"前言 由於 Heroku 取消了免費的服務\u0026hellip;個人作品都壞掉了，因此換成 Fly.io 部署\n在 Ｆly.io 建立專案 步驟 1：安裝 flyctl 這裡教學以 macOS 為例，可參考 官網 。\nbrew install flyctl 步驟 2：註冊並登入 會彈出瀏覽器視窗，可以連結 GitHub 帳號。\nflyctl auth signup flyctl auth login 步驟 3：啟動既有專案 cd 到專案後，下flyctl launch，輸入專案的名稱。\n選擇 server region，我這邊選擇香港(Hong Kong)。\n注意帳號一定要綁定信用卡才行用 會問需要使用 DB 嗎?這裡就看需求了(剛好我這個專案需要)，我就選 Yes 。\n步驟 4：開始部署 flyctl deploy 這時在終端機看到succeeded代表完成部署🎉\n可以在終端機下flyctl logs除錯\n步驟 5：訪問自己網站 可以從https://fly.io/dashboard查看所建立的 APP ，裡面會有 Hostname。\n結語 Heroku 轉移至 Fly.io，讓我的小皮妞Bot復活，但要小心不要亂搞避免產生額外費用參考。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/10/heroku-to-flyio/","tags":["Heroku","Fly.io"],"title":"Heroku 轉移至 Fly.io "},{"categories":["Notes"],"contents":"前言 在寫 Markdown 文章時候，想要為 link 添加 {target=\u0026quot;_blank\u0026quot;} 屬性參考文章，但卻起不了作用(會變字串)。\n這是一個連結[網站](http://example.com){target=\u0026#34;_blank\u0026#34;}的示例。 這是在猜想可能是 Hugo 版本不相容，就用上網找了解法，他說：Hugo 的安全模式可能會阻止執行 JavaScript。在安全模式下，Hugo 默認會禁用 JavaScript 和某些 HTML 標籤以增加網站的安全性。\n他說可以在config.toml進行配置，禁用 Hugo 的安全模式。\n[markup] [markup.goldmark] [markup.goldmark.renderer] unsafe = true 但這個方法是可以執行另開網站，但會有安全性風險，所以我就棄用了。\n解決方案：在 Markdown 添加 ShortCodes 步驟 1：在themes/layouts底下新增一個資料夾shortcodes，並建立target-blank.html 並添加以下內容，這個 ShortCode 將創建target=\u0026quot;_blank\u0026quot;屬性，並帶兩個參數。\n.Get \u0026quot;url\u0026quot; 用來指定 Link 的 URL。 .Inner 用來指定 Link 的 文本。 \u0026lt;a href=\u0026#34;{{ .Get \u0026#34;url\u0026#34; }}\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;{{ .Inner }}\u0026lt;/a\u0026gt; 步驟 2：加在想要 Markdown 中 注意 shortCode 命名盡量跟 html 文件名保持ㄧ至。\n結語 看完以上內容，可以完成解決 Hugo Markdown 連結無法另開網頁問題，如果以上有問題歡迎討論。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/10/target-blank-logo/","tags":["Hugo"],"title":"解決 Hugo Markdown 連結無法另開網頁問題"},{"categories":["Tech"],"contents":"前言 SEO是什麼？： SEO 代表搜索引擎優化，它是一系列策略和技術，用於提高網站在搜索引擎中的排名。\n為什麼它如此重要？： SEO 是吸引有機流量、提高品牌知名度、增加潛在客戶和改善線上業務成功的關鍵因素。\n本文的目標：以下是使用 Hugo 產生靜態網頁的 SEO 最佳化建議。\n設定頁面關鍵字 步驟 1：在該篇文章 Markdown 添加 keywords keywords: - Hugo SEO - 靜態網頁SEO - SEO最佳化建議 - 搜尋引擎優化 - 網站排名 步驟 2：添加 meta 標籤 這邊我是加在themes/layouts/partials/head.html裏面。\n{{ with .Params.keywords }} \u0026lt;meta name=\u0026#34;keywords\u0026#34; content=\u0026#34;{{ delimit . \u0026#34;, \u0026#34; }}\u0026#34;\u0026gt; {{ end }} {{ with .Params.keywords }}這是一個條件語句，检查文章 Markdown 文件中是否存在keywords字段 ，然而delimit用逗號和空格分隔成一個字符串。\n步驟 3：打包後看 html 結果，這樣就完成頁面關鍵字設定 \u0026lt;meta name=\u0026#34;keywords\u0026#34; content=\u0026#34;Hugo SEO, 靜態網頁SEO, SEO最佳化建議, 搜尋引擎優化, 網站排名\u0026#34;\u0026gt; 設定頁面標題 步驟 1：在該篇文章 Markdown 添加 title title: \u0026#34;Hugo SEO（搜尋引擎優化）實踐\u0026#34; 步驟 2：添加 title 標籤 這邊我是加在themes/layouts/partials/head.html裏面。\n這段意思是：如果當前頁面不是首頁，則會在標題中包括網站的名稱，以區分首頁和其他頁面的標題顯示方式。如果當前頁面是首頁，則只顯示頁面的標題，不包括網站名稱。 \u0026lt;title\u0026gt;{{ $isHomePage := eq .Title .Site.Title }}{{ .Title }}{{ if eq $isHomePage false }} - {{ .Site.Title }}{{ end }}\u0026lt;/title\u0026gt; 步驟 3：打包後看 html 結果，這樣就完成頁面標題設定 \u0026lt;title\u0026gt;Hugo SEO（搜尋引擎優化）實踐\u0026lt;/title\u0026gt; 設定頁面描述 步驟 1：在該篇文章 Markdown 添加 description description: \u0026#34;Hugo 產生靜態網頁的 SEO 最佳化建議\u0026#34; 步驟 2：添加 meta 標籤 這邊我是加在themes/layouts/partials/head.html裏面。\n這段意思是同頁面標題 \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;{{ with .Description }}{{ . }}{{ else }}{{ with .Site.Params.description }}{{ . }}{{ end }}{{ end }}\u0026#34;\u0026gt; 步驟 3：打包後看 html 結果，這樣就完成頁面描述設定 \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;Hugo 產生靜態網頁的 SEO 最佳化建議\u0026#34;\u0026gt; 結語 正確使用關鍵字可以提高您的文章在搜尋引擎中的排名，但不要忘記提供高質量的內容和有價值的信息。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/10/hugo-seo/","tags":["Hugo","SEO"],"title":"Hugo SEO（搜尋引擎優化）實踐"},{"categories":["Tech"],"contents":"前言 想要針對各特定頁面觸發事件和追蹤點擊事件，該怎麼做？\n特定頁面觸發事件 步驟 1：建立事件 可到 Google Analytics 點選左下角齒輪管理/資源設定/事件創建。\n這邊舉例/about頁面事件\n可以去 Debug View 偵測事件\n步驟 2：新增轉換 可到 Google Analytics 點選左下角齒輪管理/資源設定/轉換。\n這邊舉例about_me_page事件名稱轉換\n追蹤點擊事件 步驟 1：建立事件 同上，在資源事件設定。\n這邊舉例點擊Social/github圖示事件\n步驟 2：新增轉換 同上，在資源轉換設定。\n進階實作-如何在個人網站中自訂事件發送給GA 在 Hugo 程式碼加入 gTag Event，這邊我用點擊Know More按鈕作為 Demo，只要在程式中添加以下圖是代碼就可以發事件給 GA。\n當使用者點擊具有 \u0026ldquo;knowMoreButton\u0026rdquo; ID 的按鈕時，這段 JavaScript 代碼會觸發一個自定義事件，並將事件數據發送到 Google Analytics。這個事件包括事件名稱（\u0026ldquo;know_more_button_click\u0026rdquo;）、事件類別（\u0026ldquo;按鈕點擊\u0026rdquo;）、事件標籤（\u0026ldquo;點擊了更多按鈕\u0026rdquo;）和一個可選的值（1，用於量化事件的價值）。這有助於跟踪 Google Analytics 中使用者點擊 \u0026ldquo;Know More\u0026rdquo; 按鈕的互動。\n這時在個人網頁觸發幾次Know More事件，可以在 Google Analytics 即時報表上看到數據了。\n結語 透過自訂事件\u0026amp;轉換更能追蹤自己想要的數據了🎉\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/10/google-analytics-setting/","tags":["GA","Google"],"title":"如何在 Google Analytics 4 自訂事件\u0026轉換"},{"categories":["Notes"],"contents":"前言 介紹通用版 GA 與 GA4 差異 通用版 GA：追蹤網頁資料為核心。\nGA4：事件為核心。\n這個簡單的表格比較了通用版 GA 和 GA4 在數據收集方式、用戶跟踪、報告功能、用戶隱私和未來支持等方面的主要差異。\n網站流量 5 大面向 訪客量：每段時間有多少訪客量。\n相關性：多少比例訪客是目標客群。\n參與度：訪客在網站上行為。\n持續性：訪客的回鍋。\n收益：這些訪客量是否帶來轉換價值或收益。\nGoogle Analytics 帳戶設定 步驟 1：Google 信號啟用 在資源設定/資料收集的 Google 信號資料收集把它打開。\n步驟 2：啟用加強評估 打開後 Google 會自動評估網站上的互動和內容，並建立成事件。\n步驟 3：事件保留時間 GA4 預設保留 2 個月，建議調整成 14 個月。\n步驟 4：歸因分析設定 報表歸因模式及回朔期調整紅匡預設內容即可。\n步驟 5：如何設定網域然後做跨網域評估 可讓跨網域評估成效，並進一步定義網站上的哪些連結，在使用加強評估時不會觸發外連點擊事件。\n例如：主網站＋另1個獨立個網域，想要合併評估成效\n如何設定：資料串流(選擇你的資料)/Google代碼(進行代碼設定)/設定網域/跨網域連結設定\n步驟 6：排除非必要流量 如何設定：資料串流(選擇你的資料)/Google代碼(進行代碼設定)/列出不適用的參照連結網址\n步驟 7：Search Console 連結 進到 Search Console 按下連結選擇帳號即可。\nGA4 事件介紹 根據現有事件，建立新事件 特定頁面：\nevent_name = page_view\npage_location 包含 xxx\n點擊事件：\nevent_name = click\nlink_url 包含 xxx\n根據值觸發事件 purchase 事件且值至少為 1000\nevent_name = purchase\nvalue 大於或等於 1000\n參數設定有打勾從來源複製事件參數，可以沿用事件既有參數配置\n可以用GA4 Debug View，測試事件\n結語 透過此篇介紹來更加了解 GA4。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/10/google-analytics-introduction/","tags":["GA","Google"],"title":"Google Analytics 4 介紹"},{"categories":["Tech"],"contents":"前言 目的想在 Google 被搜尋到我的個人 Blog\n開始添加 Google Search Console 步驟 1：點擊 Google Search Console，後按下「立即開始」，就可以開始設定 步驟 2：選取資源類型 點擊網址前置字元區塊，輸入個人網站網址後，按繼續，這時如果有設定好 GA，他這邊會透過 GA 去驗證你的網站，點擊前往資源。\n步驟 3：新增 Sitemap 點選側邊選單 Sitemap 填寫網址，輸入sitemap.xml即可。\nSitemap：會把網站所有頁面列出來在這個檔案裡，在把 Sitemap 這個檔案上傳到 Google Search Console上，Google 會將這些頁面存到 Google 搜尋引擎裡面，這樣別人在 Google 搜尋時就能找到你的個人網站了。 實際會在打包後產出public/sitemap.xml檔案裡，這些檔案會列出個人網站所有頁面、每個頁面修改時間，到時候會被 Google Search 就能找到。\n步驟 4：檢查 Blog 能夠被 Google 搜尋到 方法：在 Google Search 輸入site:個人網站網址\nsite:ChrisLinOvO.github.io 剛建立好可能要等明天才搜尋的到\n也可以 Google Search Console 手動建立索引，要求指定頁面加到 Google 搜尋引擎裡面\n結語 看完以上內容，趕快加入 Google Search Console，可以輕鬆查看在 Google Search 數據及報表，若要提升搜尋結果排行較前面，可進行 SEO 優化，之後會再做介紹。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/10/google-search-console/","tags":["Google"],"title":"添加 Google Search Console"},{"categories":["Tech"],"contents":"前言 想查看使用者對於我的網站網站互動\n開始添加 Google Analytics 步驟 1：點擊 Google Analytics，後按下「開始測量」，就可以開始設定 步驟 2：建立帳戶 輸入帳戶名稱後，往下拉下面不用改，按下一步。\n步驟 3：建立資源 輸入屬性名稱，下面報表時區、幣別可以不用改，按下一步。\n步驟 4：選擇商家資訊 選擇產業類別(平常寫的文章什麼類型)，按下一步。\n步驟 5：選擇業務目標 這裡我是選擇「產生待開發客戶」、「檢視使用者行為」，這兩個都可以透過事件追蹤功能來記錄關鍵的互動，按下建立。\n步驟 6：著手收集資料 點選網站平台後，設定您的網頁串流，輸入網站網址及名稱後，建立串流。\n步驟 7：加入 Google 代碼至主題 建立完成後會出現「網頁串流詳情」，這時按下「查看代碼操作說明」，會出現手動安裝代碼，\n將代碼貼到themes/layouts/partials/head.hml裡面即可。\n如果是下載比較新版的主題，要把舊版 GA 設定刪除，需在head.html原本設定的 GA 以及config.toml裡面googleAnalitycsID移除\n步驟 8：確認 GA 與個人網站連結成功 結語 看完以上內容，可以完成加入 GA4，至於 GA4 的靈魂「事件」可能研究過後整理一篇文章做介紹。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/10/hugo-google-analytics/","tags":["GA","Google","Hugo"],"title":"Hugo 添加 Google Analytics"},{"categories":["Tech"],"contents":"前言 Utterances 是一種基於 GitHub Issues 的評論系統。它允許在靜態網站中嵌入一個評論框，並將評論存儲在與自己的 GitHub 存儲庫相關聯的 Issues 中。\n安裝 Utterances 及配置 步驟 1：到安裝頁面後點選 Install 步驟 2：選擇要安裝 Utterances 的 GitHub Repository 步驟 3：添加配置至程式碼中 可由官網進行配置\n設置 repo 名稱 選擇訪客留言 issue 名稱 選擇主題 可複製產出的代碼貼在自己的 repo 這邊我是放在themes/layouts/partials資料夾建立一個comments.html，把生成的代碼複製過去。\n\u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;ChrisLinOvO/ChrisLinOvO.github.io\u0026#34; issue-term=\u0026#34;pathname\u0026#34; theme=\u0026#34;github-light\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async \u0026gt;\u0026lt;/script\u0026gt; 若每篇文章最底下要加評論，只需要在themes/layouts/_default/single.html裡加上\n{{ partial \u0026#34;comments.html\u0026#34; . }} 結語 Utterances 是一個方便的評論系統，可用於 Hugo 靜態網站，它與 GitHub 整合，並通過 Issues 存儲評論，使評論管理變得簡單而有效。添加 Utterances 評論系統可以提升您的網站的互動性和參與度。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/10/hugo-comments/","tags":["Hugo","Git"],"title":" Hugo 添加評論功能"},{"categories":["Tech"],"contents":"前言 之前用的 Jekyll 主題創作者沒在維護，現在版本的 GitHub 不能 build 了，轉移至 Hugo 架設個人網站\n為什麼選擇 Hugo？ Hugo 是一個以 Go 語言編寫的快速靜態網站生成器，它提供了許多優點，包括：\n速度快： Hugo 生成靜態網站的速度極快，這意味著網站的頁面將在訪問者瀏覽時迅速加載。\n主題和佈局： Hugo 具有豐富的主題和佈局選擇，使你能夠輕鬆自定義你的網站外觀。\n活躍的社群： Hugo 有一個活躍的社群，提供了大量的支持和資源，幫助你解決問題。\n易於安裝和部署： Hugo 的安裝和部署過程非常簡單，無論你是使用本地主機還是部署到網路主機，都能輕鬆完成。\n如何在 Mac 上使用 Hugo 運行個人網站？ 步驟 1：安裝 Hugo 安裝 Homebrew\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; 安裝 Hugo\nbrew install hugo 確認 Hugo 安裝成功，並且有出現版本訊息\nhugo --version 因為 macOS 14 的預覽版 (pre-release version)， Homebrew 不支援，所以在安裝 Hugo 和 Git 遇到一些問題。\n可以用以下指令安裝\nbrew install --build-from-source git brew install --build-from-source hugo 步驟 2：匯入主題 這邊我是使用 liva-hugo 主題。\n這裡示範下載 git 上面 zip，下載解壓縮後，裡面有一個資料夾叫exampleSite，把他拉出來放置桌面或其他想存放的路徑。\n然後在exampleSite底下建立一個資料夾命名為themes(注意! 一定要是這個名稱 )， 然後再把解壓縮後的liva-hugo-master，改名為liva-hugo，將這個資料夾放置themes底下。\n步驟 3：啟動 Local Server 打開終端機，進去exampleSite，並啟動 server，將網址放入網頁瀏覽器中，即可以看到畫面。\nhugo server 步驟 4：設置網站配置 可以從根目錄下的config.toml文件中設置網站配置文件，包括站點標題、作者資訊、主題選擇和其他自定義設置。\n介紹其中幾個配置\nbaseURL = https://github帳號.github.io\ntitle = 網站標題配置\nlanguageCode = 網站語系配置\n[menu] = 導航配置\n[params] = 默認參數配置\n[params.search] = 搜索功能配置\n[params.cookies] = Cookie 的啟用及有效時間配置\n[params.social] = 社交媒體配置\n步驟 5：建立 GitHub Page Repository 首先到你的 GitHub 主頁，並且在右上角找到「+」，點選「New Repository」，\nRepository Name 填寫「使用者名稱.github.io」。\n步驟 6：發布至 GitHub Pages 上 編輯好後，在終端機輸入hugo，打包完成將創建一個public目錄`，\n將public裡面所有資料夾和檔案複製到 Clone 下來的使用者名稱.github.io資料夾，推上 GitHub 即可完成部署。\ngit add . \u0026amp;\u0026amp; git commit -m \u0026#34;first commit\u0026#34; \u0026amp;\u0026amp; git push 結語 遷移個人網站從 Jekyll 到 Hugo 可能需要一些工作，但它將確保你的網站保持現代化，並且更易於維護。Hugo 是一個功能豐富且強大的工具，能夠幫助你建立一個引人注目的網站，並提供快速且優質的用戶體驗。\n","permalink":"https://ChrisLinOvO.github.io/blogs/2023/10/jekyll-to-hugo/","tags":["Hugo","Git"],"title":"使用 Hugo 在 GitHub 上架設個人網站"}]